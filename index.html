<!DOCTYPE html>
<html>
<head>
    <title>แผนที่แสดงข้อมูลผู้ป่วย</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Kanit', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #333;
        }
        .container {
            width: 95%;
            max-width: 1200px;
            margin: 20px auto;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-top: 0;
            font-size: 1.5em; /* Adjusted for better responsiveness */
        }
        /* Adjusted .controls style for external placement */
        .controls {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px; /* Increased padding */
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center; /* Center horizontally */
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px; /* Space between controls and map */
            border: 1px solid #eee; /* Slight border for definition */
        }
        .controls label {
            font-weight: bold;
            color: #555;
        }
        .controls select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 16px;
            cursor: pointer;
            outline: none;
            transition: border-color 0.3s;
        }
        .controls select:focus {
            border-color: #3498db;
        }
        #mapid {
            height: 500px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            position: relative; /* Keep relative for inner Leaflet elements */
            margin-bottom: 20px; /* Space between map and chart */
        }
        .info-box {
            background: white;
            padding: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            font-size: 14px;
        }
        .legend {
            line-height: 18px;
            color: #555;
            background: white;
            padding: 6px 8px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
        .map-label-div-icon {
            font-size: 12px;
            font-weight: bold;
            color: #4a4a4a;
            text-align: center;
            line-height: 1.2;
            white-space: nowrap;
            border-radius: 4px;
            padding: 3px 6px;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid #ccc;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        #chartContainer {
            margin-top: 20px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }

        /* Styles for the stacked horizontal bar chart */
        .stacked-bar-chart {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Space between bars */
            padding-top: 15px;
        }
        .bar-item {
            display: flex;
            align-items: center;
            font-size: 14px;
            position: relative;
        }
        .bar-label {
            flex-shrink: 0;
            width: 150px; /* Fixed width for labels */
            text-align: right;
            padding-right: 10px;
            font-weight: 500;
            color: #555;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        .bar-body {
            flex-grow: 1;
            height: 25px; /* Height of the bar */
            border-radius: 4px;
            display: flex;
            overflow: hidden; /* Ensure rounded corners apply to children */
            background-color: #e0e0e0; /* Fallback for 0% bars */
            cursor: pointer; /* Added for tooltip indication on the whole bar */
        }
        .bar-segment {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
            font-size: 12px;
            box-sizing: border-box;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: width 0.5s ease-out; /* Smooth transition */
            padding: 0 3px; /* Small padding inside segments */
        }
        .outcome-legend {
            margin-top: 15px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .outcome-legend-item {
            display: flex;
            align-items: center;
            font-size: 14px;
            color: #555;
        }
        .outcome-legend-item i {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            border-radius: 3px;
        }

        /* Styles for Custom Tooltip */
        #customTooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            pointer-events: none; /* Allows mouse events to pass through */
            opacity: 0; /* Initially hidden */
            transition: opacity 0.2s ease-in-out;
            z-index: 9999; /* Ensure it's on top */
            white-space: pre-line; /* Allow text wrapping for multiple lines */
            text-align: left;
        }
        #customTooltip.show {
            opacity: 1;
        }
        /* Style for the colored dot in the tooltip */
        .tooltip-color-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }


        /* Define colors for each outcome */
        /* Updated colors based on user request */
        .outcome-Completed { background-color: #4CAF50; /* เขียว */ }
        .outcome-Cured { background-color: #006400; /* เขียวเข้ม */ }
        .outcome-OnTreatment { background-color: #87CEEB; /* ฟ้า */ }
        .outcome-TransferredOut { background-color: #CFD8DC; /* เทาอ่อน */ }
        .outcome-Died { background-color: #F44336; /* แดง */ }
        .outcome-LostToFollowUp { background-color: #FFC107; /* เหลืองส้ม */ }
        .outcome-Failed { background-color: #9932CC; /* ม่วง */ }
        .outcome-RRMDRBeforeMonth5 { background-color: #FF9800; /* ส้ม */ }
        .outcome-ChangeDiagnosis { background-color: #616161; /* เทาเข้ม */ }
        .outcome-Undefined { background-color: #B0BEC5; /* Light Blue Grey for 'ไม่ระบุ' */ }


        /* Styles for AI Analysis Section */
        #analysisResults {
            margin-top: 20px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }
        #analysisResults h2 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        #analysisResults h3 { /* New style for sub-headings */
            color: #34495e;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.2em;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }
        #analysisResults p {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
            color: #555;
            text-align: justify;
        }
        #analysisResults ul {
            list-style-type: disc;
            margin-left: 25px;
            margin-bottom: 15px;
            color: #555;
        }
        #analysisResults ul li {
            margin-bottom: 5px;
        }

        /* Loading Overlay Styles */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5em;
            z-index: 2000;
            display: none; /* Hidden by default */
            backdrop-filter: blur(5px); /* Optional: blur background */
        }
        #loadingOverlay .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                width: 100%;
                margin: 0;
                padding: 10px;
            }
            h1 {
                font-size: 1.5em; /* Reduced for tablets */
            }
            #mapid {
                height: 400px; /* Slightly reduce map height for tablets */
            }
            .controls {
                position: relative; /* Not absolute anymore */
                top: auto;
                left: auto;
                margin-bottom: 15px;
                flex-direction: column;
                align-items: stretch;
                width: auto; /* Adjust width to fit container */
                box-sizing: border-box;
            }
            .controls label,
            .controls select {
                width: 100%;
                box-sizing: border-box;
            }
            .bar-label {
                width: 100px; /* Adjust label width for smaller screens */
            }
            .bar-segment {
                font-size: 10px; /* Smaller font for value on small screens */
            }
            .outcome-legend {
                flex-direction: column;
                gap: 10px;
            }
            #analysisResults h2 {
                font-size: 1.2em;
            }
            #analysisResults h3 {
                font-size: 1.1em;
            }
            #analysisResults p {
                font-size: 1em;
            }
            #analysisResults ul {
                margin-left: 20px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.2em; /* Further reduce for very small phones */
            }
            #mapid {
                height: 300px; /* Reduce map height significantly for phones */
            }
            .bar-label {
                width: 80px; /* Further adjust label width */
                font-size: 12px; /* Smaller font for labels */
            }
            .bar-segment {
                font-size: 9px; /* Even smaller font for values */
                padding: 0 2px;
            }
            .bar-body {
                height: 20px; /* Slightly thinner bars */
            }
            .outcome-legend-item,
            .bar-item {
                font-size: 13px; /* Smaller general text */
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>แผนที่แสดงจำนวนและข้อมูลผู้ป่วยวัณโรค ปีงบประมาณ 2568</h1>
        <h1>จังหวัดนครสวรรค์</h1>

        <div class="controls">
            <label for="district-filter">เลือกอำเภอ:</label>
            <select id="district-filter">
                <option value="ทั้งหมด">ทั้งหมด</option>
            </select>
            <label for="outcome-filter">ผลการรักษา:</label>
            <select id="outcome-filter">
                <option value="ทั้งหมด">ทั้งหมด</option>
            </select>
            <label for="hospital-filter">เลือกโรงพยาบาล:</label>
            <select id="hospital-filter">
                <option value="ทั้งหมด">ทั้งหมด</option>
            </select>
        </div>

        <div id="mapid">
            </div>

        <div id="chartContainer">
            <h2>ผลงานการรักษาสำเร็จของผู้ป่วยวัณโรคทุกประเภท (All type Success rate) ปีงบประมาณ 2568</h2>
            <div id="outcomeChartLegend" class="outcome-legend"></div>
            <div id="staticHospitalChart" class="stacked-bar-chart"></div>
        </div>

        <div id="analysisResults">
            <h2>ผลการวิเคราะห์ข้อมูลผู้ป่วยวัณโรค (โดย AI)</h2>
            <div id="analysisParagraphs">
                <p>กำลังโหลดผลการวิเคราะห์...</p>
            </div>
        </div>

    </div>
    <div id="customTooltip"></div>
    <div id="loadingOverlay">
        <div class="spinner"></div>
        <span>กำลังวิเคราะห์ข้อมูล... โปรดรอสักครู่</span>
    </div>

    <script>
        const map = L.map('mapid').setView([13.7563, 100.5018], 6);
        let geoJsonLayer;
        let labelLayerGroup = L.featureGroup().addTo(map);
        let allAggregatedData; // Stores aggregated data for all hospitals
        let rawGeojsonData; // Stores the original, unaggregated GeoJSON data
        let legend;
        const customTooltip = document.getElementById('customTooltip');

        // Define the desired order for outcomes in the chart and legend
        const outcomeDisplayOrder = [
            'Completed',
            'Cured',
            'On treatment',
            'Transferred out',
            'Died',
            'Lost to follow-up',
            'Failed', // Assuming 'Failed' might exist or be added.
            'RR/MDR ก่อนเดือนที่ 5',
            'Change diagnosis',
            'ไม่ระบุ' // Always include 'ไม่ระบุ' at the end
        ];

        // Define a mapping from outcome names to CSS class names for colors
        // Ensure this list is exhaustive of all possible outcomes
        const outcomeColorClasses = {
            'Completed': 'outcome-Completed',
            'Cured': 'outcome-Cured',
            'On treatment': 'outcome-OnTreatment',
            'Transferred out': 'outcome-TransferredOut',
            'Died': 'outcome-Died',
            'Lost to follow-up': 'outcome-LostToFollowUp',
            'Failed': 'outcome-Failed',
            'RR/MDR ก่อนเดือนที่ 5': 'outcome-RRMDRBeforeMonth5',
            'Change diagnosis': 'outcome-ChangeDiagnosis',
            'ไม่ระบุ': 'outcome-Undefined'
        };

        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        const part1Url = 'final_data_reduced_part_1.geojson';
        const part2Url = 'final_data_reduced_part_2.geojson';

        // โหลดและรวมไฟล์ GeoJSON ทั้งสองไฟล์
        async function loadAndCombineGeoJSON() {
            try {
                const [response1, response2] = await Promise.all([
                    fetch(part1Url),
                    fetch(part2Url)
                ]);

                if (!response1.ok || !response2.ok) {
                    throw new Error('ไม่สามารถดึงข้อมูลจากไฟล์ GeoJSON ได้');
                }

                const data1 = await response1.json();
                const data2 = await response2.json();
                return {
                    "type": "FeatureCollection",
                    "features": [...data1.features, ...data2.features]
                };
            } catch (error) {
                console.error("เกิดข้อผิดพลาดในการโหลดหรือรวมไฟล์:", error);
                return null;
            }
        }

        // รวมข้อมูลผู้ป่วยตาม จังหวัด-อำเภอ-ตำบล
        function aggregateData(geojsonData) {
            const aggregatedFeatures = {};
            geojsonData.features.forEach(feature => {
                const props = feature.properties;
                const geoKey = `${props['จังหวัด']}-${props['อำเภอ']}-${props['ตำบล']}`;
                // Use 'ไม่ระบุ' if outcome is null or undefined
                const outcome = props['ผลการรักษา'] || 'ไม่ระระบุ'; // Fixed typo here, was 'ไม่ระบุ'

                if (!aggregatedFeatures[geoKey]) {
                    aggregatedFeatures[geoKey] = {
                        type: 'Feature',
                        geometry: feature.geometry,
                        properties: {
                            'จังหวัด': props['จังหวัด'],
                            'อำเภอ': props['อำเภอ'],
                            'ตำบล': props['ตำบล'],
                            'total_count': 0,
                            'outcome_counts': {}
                        }
                    };
                }

                aggregatedFeatures[geoKey].properties.total_count++;

                if (!aggregatedFeatures[geoKey].properties.outcome_counts[outcome]) {
                    aggregatedFeatures[geoKey].properties.outcome_counts[outcome] = 0;
                }
                aggregatedFeatures[geoKey].properties.outcome_counts[outcome]++;
            });

            return {
                "type": "FeatureCollection",
                "features": Object.values(aggregatedFeatures)
            };
        }

        // กำหนดสีตามจำนวนผู้ป่วย (สำหรับแผนที่)
        function getColorForCount(count) {
            return count > 50 ? '#800026' :
                count > 20 ? '#BD0026' :
                    count > 10 ? '#E31A1C' :
                        count > 5 ? '#FC4E2A' :
                            count > 2 ? '#FD8D3C' :
                                count > 0 ? '#FED976' :
                                    '#f0f0f0';
        }

        // สร้าง popup สำหรับแต่ละ feature (แค่ bind popup ไม่ใส่ event hover)
        function onEachFeature(feature, layer) {
            const props = feature.properties;
            const totalCount = props['total_count'];
            let popupContent = `
            <b>จังหวัด:</b> ${props['จังหวัด']}<br>
            <b>อำเภอ:</b> ${props['อำเภอ']}<br>
            <b>ตำบล:</b> ${props['ตำบล']}<br>
            <hr>
            <b>ยอดรวมผู้ป่วย:</b> ${totalCount}<br>
            <hr>
            <b>แบ่งตามผลการรักษา:</b><br>
        `;

            // Sort outcomes for popup consistently (alphabetically or by custom order if desired for popup too)
            // For popup, alphabetical sorting is generally fine for readability
            const sortedOutcomes = Object.keys(props.outcome_counts).sort();
            for (const outcome of sortedOutcomes) {
                const outcomeCount = props.outcome_counts[outcome] || 0;
                const percentage = totalCount > 0 ? ((outcomeCount / totalCount) * 100).toFixed(1) : 0;
                popupContent += `• ${outcome}: ${outcomeCount} ราย (${percentage}%)<br>`;
            }

            layer.bindPopup(popupContent);
        }

        // สร้าง Dropdown สำหรับอำเภอ
        function createDistrictFilter(districts) {
            const selectElement = document.getElementById('district-filter');
            districts.forEach(district => {
                const option = document.createElement('option');
                option.value = district;
                option.textContent = district;
                selectElement.appendChild(option);
            });
            selectElement.addEventListener('change', applyFilters);
        }

        // สร้าง Dropdown สำหรับผลการรักษา
        function createOutcomeFilter(outcomes) {
            const selectElement = document.getElementById('outcome-filter');
            outcomes.forEach(outcome => {
                const option = document.createElement('option');
                option.value = outcome;
                option.textContent = outcome;
                selectElement.appendChild(option);
            });
            selectElement.addEventListener('change', applyFilters);
        }

        // สร้าง Dropdown สำหรับโรงพยาบาล
        function createHospitalFilter(hospitals) {
            const selectElement = document.getElementById('hospital-filter');
            hospitals.forEach(hospital => {
                const option = document.createElement('option');
                option.value = hospital;
                option.textContent = hospital;
                selectElement.appendChild(option);
            });
            selectElement.addEventListener('change', applyFilters);
        }

        // อัพเดท Legend บนแผนที่
        function updateLegend(selectedOutcome) {
            if (legend) {
                legend.remove();
            }

            legend = L.control({ position: 'bottomright' });
            legend.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'info-box legend');
                const grades = [1, 2, 5, 10, 20, 50];
                const legendTitle = selectedOutcome === 'ทั้งหมด' ? 'จำนวนผู้ป่วย' : `จำนวนผู้ป่วย (${selectedOutcome})`;

                div.innerHTML = `<b>${legendTitle}</b><br>`;
                for (let i = 0; i < grades.length; i++) {
                    div.innerHTML +=
                        '<div><i style="background:' + getColorForCount(grades[i] + 1) + '"></i> ' +
                        grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] + '<br>' : '+') + '</div>';
                }
                return div;
            };
            legend.addTo(map);
        }

        // เพิ่มป้ายกำกับจำนวนผู้ป่วยและชื่อตำบลบนแผนที่
        function addLabelsToMap(geoJsonData, selectedOutcome) {
            labelLayerGroup.clearLayers(); // Clear existing labels

            // Only show labels if an specific outcome is selected (not 'ทั้งหมด')
            if (selectedOutcome === 'ทั้งหมด') {
                return;
            }

            geoJsonData.features.forEach(feature => {
                const props = feature.properties;
                let labelText;
                let count = props.outcome_counts[selectedOutcome] || 0;

                // Only create label if count for the selected outcome is greater than 0
                if (count > 0) {
                    const totalCountInTambon = props.total_count;
                    const percentage = totalCountInTambon > 0 ? ((count / totalCountInTambon) * 100).toFixed(1) : 0;
                    labelText = `${props['ตำบล']}<br>(${count} ราย, ${percentage}%)`;

                    const centroid = L.geoJSON(feature.geometry).getBounds().getCenter();
                    const labelIcon = L.divIcon({
                        className: 'map-label-div-icon',
                        html: labelText,
                        iconSize: [0, 0], // Let content size the icon
                        iconAnchor: [0, 0] // Centered by CSS transform
                    });

                    // Using L.marker with custom divIcon for labels
                    L.marker(centroid, { icon: labelIcon }).addTo(labelLayerGroup);
                }
            });
        }

        // ฟังก์ชันสำหรับเตรียมข้อมูลและสร้าง/อัพเดทกราฟแท่งแนวนอน (Stacked)
        function renderStaticHospitalChart(data) {
            const hospitalOutcomeCounts = {}; // { hospitalName: { outcome1: count, outcome2: count, ... }, ... }
            const allOutcomesPresent = new Set(); // To collect all unique outcomes for the legend

            // Calculate overall province data first
            let overallProvinceCounts = { total: 0 };

            data.features.forEach(feature => {
                const hospital = feature.properties['โรงพยาบาล'] || 'ไม่ระบุ';
                const outcome = feature.properties['ผลการรักษา'] || 'ไม่ระบุ';

                // Aggregate for individual hospitals
                if (!hospitalOutcomeCounts[hospital]) {
                    hospitalOutcomeCounts[hospital] = { total: 0 };
                }
                if (!hospitalOutcomeCounts[hospital][outcome]) {
                    hospitalOutcomeCounts[hospital][outcome] = 0;
                }
                hospitalOutcomeCounts[hospital][outcome]++;
                hospitalOutcomeCounts[hospital].total++;

                // Aggregate for overall province
                if (!overallProvinceCounts[outcome]) {
                    overallProvinceCounts[outcome] = 0;
                }
                overallProvinceCounts[outcome]++;
                overallProvinceCounts.total++;

                allOutcomesPresent.add(outcome);
            });

            const sortedHospitals = Object.entries(hospitalOutcomeCounts).sort(([, countsA], [, countsB]) => countsB.total - countsA.total);

            const chartContainer = document.getElementById('staticHospitalChart');
            chartContainer.innerHTML = ''; // Clear existing bars

            if (sortedHospitals.length === 0 && overallProvinceCounts.total === 0) {
                chartContainer.innerHTML = '<p style="text-align: center; color: #777;">ไม่มีข้อมูลผู้ป่วยสำหรับโรงพยาบาล</p>';
                document.getElementById('outcomeChartLegend').innerHTML = ''; // Clear legend too
                return;
            }

            // Render Overall Province Bar (if there's data)
            if (overallProvinceCounts.total > 0) {
                renderBar('ภาพรวมจังหวัดนครสวรรค์', overallProvinceCounts, chartContainer);
            }

            // Render individual hospital bars
            sortedHospitals.forEach(([hospitalName, outcomeCounts]) => {
                renderBar(hospitalName, outcomeCounts, chartContainer);
            });

            // Render chart legend (call separately to ensure all unique outcomes are collected)
            // Filter outcomeDisplayOrder to only include outcomes actually present in the data for the legend
            const relevantOutcomesForLegend = outcomeDisplayOrder.filter(outcome => allOutcomesPresent.has(outcome));
            renderOutcomeChartLegend(relevantOutcomesForLegend);
        }

        // Helper function to render a single bar (for hospital or overall)
        function renderBar(name, outcomeCounts, containerElement) {
            const barItem = document.createElement('div');
            barItem.classList.add('bar-item');

            const barLabel = document.createElement('div');
            barLabel.classList.add('bar-label');
            barLabel.textContent = name;
            barItem.appendChild(barLabel);

            const barBody = document.createElement('div');
            barBody.classList.add('bar-body');

            // Add event listeners for custom tooltip to the whole barBody
            barBody.addEventListener('mouseover', (e) => {
                let tooltipText = `<b>${name}</b><br>ยอดรวมผู้ป่วย: ${outcomeCounts.total} ราย<br><br>แบ่งตามผลการรักษา:<br>`;
                // Use outcomeDisplayOrder for tooltip content as well for consistency
                outcomeDisplayOrder.forEach(outcome => {
                    const count = outcomeCounts[outcome] || 0;
                    if (count > 0 || outcome === 'ไม่ระบุ') { // Show 'ไม่ระบุ' even if 0 count for clarity
                        const percentage = outcomeCounts.total > 0 ? ((count / outcomeCounts.total) * 100).toFixed(1) : 0;
                        const colorClass = outcomeColorClasses[outcome] || 'outcome-Undefined';
                        tooltipText += `<span class="tooltip-color-dot ${colorClass}"></span> ${outcome}: ${count} ราย (${percentage}%)<br>`;
                    }
                });
                showTooltip(e, tooltipText);
            });
            barBody.addEventListener('mouseout', hideTooltip);
            barBody.addEventListener('mousemove', (e) => {
                moveTooltip(e);
            });

            // Iterate through the predefined display order
            outcomeDisplayOrder.forEach(outcome => {
                const count = outcomeCounts[outcome] || 0;
                const percentage = outcomeCounts.total > 0 ? ((count / outcomeCounts.total) * 100).toFixed(1) : 0;

                if (parseFloat(percentage) > 0) { // Only create segment if there's data for it
                    const barSegment = document.createElement('div');
                    barSegment.classList.add('bar-segment');
                    barSegment.classList.add(outcomeColorClasses[outcome] || 'outcome-Undefined'); // Apply color class
                    barSegment.style.width = `${percentage}%`;

                    // Display percentage for segments with value > 0
                    barSegment.textContent = `${percentage}%`;

                    barBody.appendChild(barSegment);
                }
            });

            barItem.appendChild(barBody);
            containerElement.appendChild(barItem);
        }


        // Function to show custom tooltip
        function showTooltip(event, text) {
            customTooltip.innerHTML = text; // Use innerHTML to allow for HTML in tooltip
            customTooltip.classList.add('show');
            moveTooltip(event);
        }

        // Function to move custom tooltip
        function moveTooltip(event) {
            // Position tooltip relative to mouse cursor
            const xOffset = 15; // Offset from cursor to prevent blocking
            const yOffset = 15;

            // Get boundaries of the chart container to prevent tooltip from going off-screen
            const chartRect = document.getElementById('chartContainer').getBoundingClientRect();
            const tooltipRect = customTooltip.getBoundingClientRect();

            // Add scroll position to clientX/Y
            let newX = event.clientX + window.scrollX + xOffset;
            let newY = event.clientY + window.scrollY + yOffset;

            // Adjust X if tooltip goes off right edge
            if (newX + tooltipRect.width > document.documentElement.clientWidth - 20 + window.scrollX) {
                newX = event.clientX + window.scrollX - tooltipRect.width - xOffset;
            }
            // Adjust Y if tooltip goes off bottom edge
            if (newY + tooltipRect.height > document.documentElement.clientHeight - 20 + window.scrollY) {
                newY = event.clientY + window.scrollY - tooltipRect.height - yOffset;
            }
             // Ensure tooltip doesn't go off the left edge
            if (newX < window.scrollX) {
                newX = window.scrollX;
            }
            // Ensure tooltip doesn't go off the top edge
            if (newY < window.scrollY) {
                newY = window.scrollY;
            }

            customTooltip.style.left = `${newX}px`;
            customTooltip.style.top = `${newY}px`;
        }

        // Function to hide custom tooltip
        function hideTooltip() {
            customTooltip.classList.remove('show');
            customTooltip.innerHTML = ''; // Clear text
        }

        // Function to render the legend for the stacked bar chart
        function renderOutcomeChartLegend(outcomesToDisplayInLegend) {
            const legendContainer = document.getElementById('outcomeChartLegend');
            legendContainer.innerHTML = ''; // Clear existing legend

            if (outcomesToDisplayInLegend.length === 0) {
                return;
            }

            outcomesToDisplayInLegend.forEach(outcome => {
                const legendItem = document.createElement('div');
                legendItem.classList.add('outcome-legend-item');

                const colorBox = document.createElement('i');
                colorBox.classList.add(outcomeColorClasses[outcome] || 'outcome-Undefined'); // Apply color class
                legendItem.appendChild(colorBox);

                const label = document.createElement('span');
                label.textContent = outcome;
                legendItem.appendChild(label);

                legendContainer.appendChild(legendItem);
            });
        }


        // ฟังก์ชันหลักในการกรองและอัพเดทแผนที่
        function applyFilters() {
            const selectedDistrict = document.getElementById('district-filter').value;
            const selectedOutcome = document.getElementById('outcome-filter').value;
            const selectedHospital = document.getElementById('hospital-filter').value;

            if (geoJsonLayer) {
                map.removeLayer(geoJsonLayer);
            }

            let dataToProcessForMap = rawGeojsonData.features; // Start with all raw data for map
            let dataToProcessForChart = rawGeojsonData.features; // Start with all raw data for chart

            // Filter for chart: Apply Hospital filter first
            // Note: Overall province bar will still reflect ALL filtered data
            if (selectedHospital !== 'ทั้งหมด') {
                dataToProcessForChart = dataToProcessForChart.filter(feature =>
                    feature.properties['โรงพยาบาล'] === selectedHospital
                );
            }

            // Filter for map: Apply all filters to raw data before aggregation for map display
            if (selectedHospital !== 'ทั้งหมด') {
                dataToProcessForMap = dataToProcessForMap.filter(feature =>
                    feature.properties['โรงพยาบาล'] === selectedHospital
                );
            }
            if (selectedDistrict !== 'ทั้งหมด') {
                dataToProcessForMap = dataToProcessForMap.filter(feature =>
                    feature.properties['อำเภอ'] === selectedDistrict
                );
            }
            // For the map, we aggregate after district/hospital filter
            let currentAggregatedDataForMap = aggregateData({ type: 'FeatureCollection', features: dataToProcessForMap });

            let filteredFeaturesForMap = currentAggregatedDataForMap.features;

            const newStyle = function (feature) {
                let count;
                if (selectedOutcome === 'ทั้งหมด') {
                    count = feature.properties.total_count;
                } else {
                    count = feature.properties.outcome_counts[selectedOutcome] || 0;
                }

                return {
                    color: "#ffffff",
                    weight: 1.5,
                    opacity: 0.8,
                    fillColor: getColorForCount(count),
                    fillOpacity: 0.6
                };
            };

            const filteredGeoJSONForMap = {
                "type": "FeatureCollection",
                "features": filteredFeaturesForMap
            };

            geoJsonLayer = L.geoJSON(filteredGeoJSONForMap, {
                style: newStyle,
                onEachFeature: onEachFeature
            }).addTo(map);

            // Conditionally add hover events for popups if outcome filter is 'ทั้งหมด'
            if (selectedOutcome === 'ทั้งหมด') {
                geoJsonLayer.eachLayer(function (layer) {
                    layer.on({
                        mouseover: function (e) {
                            this.openPopup();
                        },
                        mouseout: function (e) {
                            this.closePopup();
                        }
                    });
                });
            } else { // Remove hover events if a specific outcome is selected
                geoJsonLayer.eachLayer(function (layer) {
                    layer.off('mouseover');
                    layer.off('mouseout');
                });
            }


            if (filteredFeaturesForMap.length > 0) {
                map.fitBounds(geoJsonLayer.getBounds());
            }

            updateLegend(selectedOutcome);
            addLabelsToMap(filteredGeoJSONForMap, selectedOutcome); // Update labels after filtering
            renderStaticHospitalChart({ type: 'FeatureCollection', features: dataToProcessForChart }); // Update chart based on currently filtered raw data

            // Run AI analysis with the filtered raw data for the chart
            runAIAnalysis({ type: 'FeatureCollection', features: dataToProcessForChart });
        }

        // Function to simulate AI analysis and update paragraphs
        async function runAIAnalysis(data) {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const analysisParagraphs = document.getElementById('analysisParagraphs');
            loadingOverlay.style.display = 'flex'; // Show loading overlay
            analysisParagraphs.innerHTML = '<p>กำลังโหลดผลการวิเคราะห์...</p>'; // Reset content

            try {
                const totalPatients = data.features.length;
                let hospitalOutcomeCounts = {}; // To aggregate data per hospital, similar to chart

                data.features.forEach(f => {
                    const hospital = f.properties['โรงพยาบาล'] || 'ไม่ระบุ';
                    const outcome = f.properties['ผลการรักษา'] || 'ไม่ระบุ';

                    if (!hospitalOutcomeCounts[hospital]) {
                        hospitalOutcomeCounts[hospital] = { total: 0, 'Cured': 0, 'Completed': 0, 'Lost to follow-up': 0, 'Died': 0, 'On treatment':0, 'Change diagnosis':0, 'RR/MDR ก่อนเดือนที่ 5':0, 'Transferred out':0, 'Undefined':0, 'Failed':0 }; // Ensure all outcomes are initialized, added 'Failed'
                    }
                    hospitalOutcomeCounts[hospital].total++;
                    if (hospitalOutcomeCounts[hospital][outcome] !== undefined) {
                        hospitalOutcomeCounts[hospital][outcome]++;
                    } else { // Handle outcomes not explicitly listed but present in data
                         hospitalOutcomeCounts[hospital]['Undefined']++; // Fallback for unexpected outcomes
                    }
                });

                // Calculate overall province data
                let overallCured = 0;
                let overallCompleted = 0;
                let overallLost = 0;
                let overallDied = 0;
                let overallOnTreatment = 0;
                let overallChangeDiagnosis = 0;
                let overallRRMDR = 0;
                let overallTransferredOut = 0;
                let overallUndefined = 0;
                let overallFailed = 0; // New: Added Failed

                for (const hospital in hospitalOutcomeCounts) {
                    overallCured += hospitalOutcomeCounts[hospital]['Cured'];
                    overallCompleted += hospitalOutcomeCounts[hospital]['Completed'];
                    overallLost += hospitalOutcomeCounts[hospital]['Lost to follow-up'];
                    overallDied += hospitalOutcomeCounts[hospital]['Died'];
                    overallOnTreatment += hospitalOutcomeCounts[hospital]['On treatment'];
                    overallChangeDiagnosis += hospitalOutcomeCounts[hospital]['Change diagnosis'];
                    overallRRMDR += hospitalOutcomeCounts[hospital]['RR/MDR ก่อนเดือนที่ 5'];
                    overallTransferredOut += hospitalOutcomeCounts[hospital]['Transferred out'];
                    overallUndefined += hospitalOutcomeCounts[hospital]['Undefined'];
                    overallFailed += hospitalOutcomeCounts[hospital]['Failed']; // New: Added Failed
                }


                const overallSuccessRate = totalPatients > 0 ? (((overallCured + overallCompleted) / totalPatients) * 100).toFixed(1) : 0;
                const overallLostToFollowUpPercentage = totalPatients > 0 ? ((overallLost / totalPatients) * 100).toFixed(1) : 0;
                const overallDiedPercentage = totalPatients > 0 ? ((overallDied / totalPatients) * 100).toFixed(1) : 0;
                // Calculate percentages for each outcome type
                const percCured = totalPatients > 0 ? ((overallCured / totalPatients) * 100).toFixed(1) : 0;
                const percCompleted = totalPatients > 0 ? ((overallCompleted / totalPatients) * 100).toFixed(1) : 0;
                const percOnTreatment = totalPatients > 0 ? ((overallOnTreatment / totalPatients) * 100).toFixed(1) : 0;
                const percChangeDiagnosis = totalPatients > 0 ? ((overallChangeDiagnosis / totalPatients) * 100).toFixed(1) : 0;
                const percRRMDR = totalPatients > 0 ? ((overallRRMDR / totalPatients) * 100).toFixed(1) : 0;
                const percTransferredOut = totalPatients > 0 ? ((overallTransferredOut / totalPatients) * 100).toFixed(1) : 0;
                const percLostToFollowUp = totalPatients > 0 ? ((overallLost / totalPatients) * 100).toFixed(1) : 0;
                const percDied = totalPatients > 0 ? ((overallDied / totalPatients) * 100).toFixed(1) : 0;
                const percUndefined = totalPatients > 0 ? ((overallUndefined / totalPatients) * 100).toFixed(1) : 0;
                const percFailed = totalPatients > 0 ? ((overallFailed / totalPatients) * 100).toFixed(1) : 0; // New: Added Failed


                // Identify top/bottom performing hospitals based on success rate
                let hospitalPerformance = [];
                for (const hospitalName in hospitalOutcomeCounts) {
                    const hData = hospitalOutcomeCounts[hospitalName];
                    if (hData.total > 0) {
                        const successRate = ((hData['Cured'] + hData['Completed']) / hData.total * 100).toFixed(1);
                        const lostRate = (hData['Lost to follow-up'] / hData.total * 100).toFixed(1);
                        const diedRate = (hData['Died'] / hData.total * 100).toFixed(1);
                        hospitalPerformance.push({
                            name: hospitalName,
                            total: hData.total,
                            successRate: parseFloat(successRate),
                            lostRate: parseFloat(lostRate),
                            diedRate: parseFloat(diedRate)
                        });
                    }
                }

                hospitalPerformance.sort((a, b) => b.successRate - a.successRate); // Sort by success rate descending

                let topHospitals = hospitalPerformance.slice(0, Math.min(3, hospitalPerformance.length));
                let bottomHospitals = hospitalPerformance.slice(Math.max(0, hospitalPerformance.length - 3), hospitalPerformance.length).sort((a, b) => a.successRate - b.successRate);

                // --- START: Added for Console Output ---
                console.log("--- Performance Metrics for Each Hospital (as calculated for AI analysis) ---");
                if (hospitalPerformance.length > 0) {
                    hospitalPerformance.forEach(h => {
                        console.log(`Hospital: ${h.name}`);
                        console.log(`  Total Patients: ${h.total}`);
                        console.log(`  Success Rate (Cured + Completed): ${h.successRate}%`);
                        console.log(`  Lost to Follow-up Rate: ${h.lostRate}%`);
                        console.log(`  Died Rate: ${h.diedRate}%`);
                        console.log('---');
                    });
                } else {
                    console.log("No hospital data available based on current filters for detailed metrics.");
                }
                console.log("------------------------------------------------------------------");
                // --- END: Added for Console Output ---


                // Generate basic analysis paragraphs with simpler headings
                let analysisContent = '';

                if (totalPatients === 0) {
                    analysisContent = '<p><b>ไม่มีข้อมูลผู้ป่วยให้วิเคราะห์ตามเงื่อนไขที่เลือก.</b></p>';
                } else {
                    // Section 1: ภาพรวมข้อมูลผู้ป่วย
                    analysisContent += `<h3>ภาพรวมข้อมูลผู้ป่วย</h3>`;
                    analysisContent += `<p>ข้อมูลผู้ป่วยวัณโรคจำนวน <b>${totalPatients} ราย</b> (ตามตัวกรองปัจจุบัน) แสดงผลการรักษาดังนี้:</p>
                        <ul>
                            <li><b>รักษาหาย (Cured):</b> ${overallCured} ราย (${percCured}%)</li>
                            <li><b>รักษาครบ (Completed):</b> ${overallCompleted} ราย (${percCompleted}%)</li>
                            <li><b>ยังอยู่ระหว่างรักษา (On treatment):</b> ${overallOnTreatment} ราย (${percOnTreatment}%)</li>
                            <li><b>เปลี่ยนการวินิจฉัย:</b> ${overallChangeDiagnosis} ราย (${percChangeDiagnosis}%)</li>
                            <li><b>RR/MDR ก่อนเดือนที่ 5:</b> ${overallRRMDR} ราย (${percRRMDR}%)</li>
                            <li><b>ย้ายออก:</b> ${overallTransferredOut} ราย (${percTransferredOut}%)</li>
                            <li><b>ขาดการรักษา (Lost to follow-up):</b> ${overallLost} ราย (${percLostToFollowUp}%)</li>
                            <li><b>เสียชีวิต:</b> ${overallDied} ราย (${percDied}%)</li>
                            ${overallFailed > 0 ? `<li><b>ล้มเหลว (Failed):</b> ${overallFailed} ราย (${percFailed}%)</li>` : ''}
                            ${overallUndefined > 0 ? `<li><b>ไม่ระบุ:</b> ${overallUndefined} ราย (${percUndefined}%)</li>` : ''}
                        </ul>
                        <p>โดยรวมแล้ว อัตราความสำเร็จของการรักษา (หาย + ครบ) อยู่ที่ <b>${overallSuccessRate}%</b></p>
                    `;

                    // Section 2: ผลงานของโรงพยาบาล
                    analysisContent += `<h3>ผลงานของโรงพยาบาล</h3>`;
                    if (topHospitals.length > 0) {
                        analysisContent += `<p>โรงพยาบาลที่มีอัตราความสำเร็จสูง 3 อันดับแรกคือ: `;
                        topHospitals.forEach((h, index) => {
                            analysisContent += `<b>${h.name}</b> (สำเร็จ ${h.successRate}%)`;
                            if (index < topHospitals.length - 1) analysisContent += ', ';
                        });
                        analysisContent += `. โรงพยาบาลเหล่านี้ทำผลงานได้ดี ควรนำไปเป็นตัวอย่าง.</p>`;
                    }

                    if (bottomHospitals.length > 0 && bottomHospitals.length !== hospitalPerformance.length) {
                        const hospitalsWithIssues = bottomHospitals.filter(h => h.lostRate > 0 || h.diedRate > 0);
                        if (hospitalsWithIssues.length > 0) {
                           analysisContent += `<p>ส่วนโรงพยาบาลที่ยังมีความท้าทาย โดยมีสัดส่วนผู้ป่วยขาดการรักษาหรือเสียชีวิตสูง ได้แก่ ${hospitalsWithIssues.map(h => `<b>${h.name}</b>`).join(', ')}. โรงพยาบาลเหล่านี้ต้องพิจารณาหาสาเหตุและปรับปรุงการดูแลผู้ป่วย.</p>`;
                        }
                    }
                    analysisContent += `<p>สามารถดูรายละเอียดผลงานของแต่ละโรงพยาบาลได้จากกราฟแท่งด้านบน.</p>`;


                    // Section 3: ข้อสังเกตและคำแนะนำ
                    analysisContent += `<h3>ข้อสังเกตและคำแนะนำ</h3>`;
                    analysisContent += `<p>หากดูจากข้อมูลที่ผ่านมา มีข้อสังเกตและคำแนะนำดังนี้:</p><ul>`;

                    if (parseFloat(overallSuccessRate) >= 80) {
                        analysisContent += `<li><b>อัตราสำเร็จสูง:</b> ภาพรวมการรักษาวัณโรคในจังหวัดทำได้ดี ควรพยายามรักษาระดับนี้ไว้และแลกเปลี่ยนวิธีการทำงานกับโรงพยาบาลอื่น.</li>`;
                    } else {
                        analysisContent += `<li><b>ต้องปรับปรุงอัตราสำเร็จ:</b> อัตราความสำเร็จโดยรวมยังไม่ถึงเป้าหมาย (80%) ควรทบทวนขั้นตอนการรักษาและหาทางเพิ่มประสิทธิภาพ.</li>`;
                    }

                    if (parseFloat(overallLostToFollowUpPercentage) > 10) {
                        analysisContent += `<li><b>ผู้ป่วยขาดการรักษาเยอะ:</b> มีผู้ป่วยจำนวนมากที่ขาดการติดตาม ซึ่งอาจทำให้การแพร่เชื้อยังคงอยู่ ควรมีการติดตามผู้ป่วยอย่างใกล้ชิดมากขึ้น เช่น การโทรศัพท์ หรือส่ง อสม. ไปเยี่ยม.</li>`;
                    }

                    if (parseFloat(overallDiedPercentage) > 5) {
                        analysisContent += `<li><b>อัตราเสียชีวิตสูง:</b> ผู้ป่วยวัณโรคเสียชีวิตค่อนข้างมาก ควรตรวจสอบว่ามีสาเหตุใดที่สามารถป้องกันได้ และปรับปรุงการดูแลผู้ป่วยกลุ่มที่มีอาการหนักหรือมีโรคประจำตัว.</li>`;
                    }
                    // New: Add advice for Failed if present
                    if (parseFloat(percFailed) > 0 && parseFloat(percFailed) > parseFloat(percLostToFollowUp) && parseFloat(percFailed) > parseFloat(percDied)) { // Simple heuristic
                         analysisContent += `<li><b>ผลการรักษาล้มเหลว:</b> พบผู้ป่วยมีผลการรักษาล้มเหลว (${percFailed}%) ซึ่งบ่งชี้ว่าการรักษาอาจไม่เป็นไปตามแผน ควรทบทวนแนวทางการรักษาและพิจารณาปัจจัยที่ทำให้การรักษาไม่ได้ผล.</li>`;
                    }

                    analysisContent += `</ul><p>การปรับปรุงจุดที่พบปัญหาจะช่วยให้การควบคุมวัณโรคในจังหวัดนครสวรรค์ดีขึ้นได้.</p>`;
                }


                analysisParagraphs.innerHTML = analysisContent;

            } catch (error) {
                console.error("Error running AI analysis:", error);
                analysisParagraphs.innerHTML = '<p style="color: red;">เกิดข้อผิดพลาดในการวิเคราะห์ข้อมูล. โปรดลองใหม่อีกครั้ง.</p><p style="color: red;">(ข้อผิดพลาดนี้อาจเกิดจากการจำลอง API หรือการเชื่อมต่อกับ AI Backend ที่ยังไม่ได้ตั้งค่า)</p>';
            } finally {
                loadingOverlay.style.display = 'none'; // Hide loading overlay
            }
        }

        // เริ่มต้นการทำงานของแอปพลิเคชัน
        loadAndCombineGeoJSON().then(geojsonData => {
            if (geojsonData) {
                rawGeojsonData = geojsonData; // Store raw data
                allAggregatedData = aggregateData(geojsonData); // Aggregate all data for initial 'ทั้งหมด' state

                const districts = [...new Set(allAggregatedData.features.map(f => f.properties['อำเภอ']))].sort();

                const allOutcomes = new Set();
                rawGeojsonData.features.forEach(feature => { // Get all outcomes from raw data
                    const outcome = feature.properties['ผลการรักษา'] || 'ไม่ระบุ';
                    allOutcomes.add(outcome);
                });
                const outcomes = [...allOutcomes].sort(); // Keep this for the filter dropdown, it's alphabetical

                const hospitals = [...new Set(rawGeojsonData.features.map(f => f.properties['โรงพยาบาล']))].sort(); // Extract hospitals from raw data

                createDistrictFilter(districts);
                createOutcomeFilter(outcomes);
                createHospitalFilter(hospitals); // Create hospital filter

                // Initial map load uses all aggregated data
                geoJsonLayer = L.geoJSON(allAggregatedData, {
                    style: function (feature) {
                        return {
                            color: "#ffffff",
                            weight: 1.5,
                            opacity: 0.8,
                            fillColor: getColorForCount(feature.properties.total_count),
                            fillOpacity: 0.6
                        };
                    },
                    onEachFeature: onEachFeature
                }).addTo(map);

                // Add hover events for popups on initial load (since outcome filter is 'ทั้งหมด')
                geoJsonLayer.eachLayer(function (layer) {
                    layer.on({
                        mouseover: function (e) {
                            this.openPopup();
                        },
                        mouseout: function (e) {
                            this.closePopup();
                        }
                    });
                });


                map.fitBounds(geoJsonLayer.getBounds());

                updateLegend('ทั้งหมด');
                // Initial call to addLabelsToMap, checks current filter state
                addLabelsToMap(allAggregatedData, document.getElementById('outcome-filter').value);
                // Initial chart render with all raw data
                renderStaticHospitalChart(rawGeojsonData);

                // Initial AI analysis run after everything loads
                runAIAnalysis(rawGeojsonData);
            }
        });

        L.control.scale({ imperial: false, position: 'bottomleft' }).addTo(map);
    </script>

</body>
</html>
