<!DOCTYPE html>
<html>

<head>
    <title>แผนที่แสดงข้อมูลผู้ป่วย</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Kanit', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #333;
        }

        .container {
            width: 95%;
            max-width: 1200px;
            margin: 20px auto;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-top: 0;
            font-size: 1.5em;
            /* Adjusted for better responsiveness */
        }

        /* Adjusted .controls style for external placement */
        .controls {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            /* Increased padding */
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            /* Center horizontally */
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            /* Space between controls and map */
            border: 1px solid #eee;
            /* Slight border for definition */
        }

        .controls label {
            font-weight: bold;
            color: #555;
        }

        .controls select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 16px;
            cursor: pointer;
            outline: none;
            transition: border-color 0.3s;
        }

        .controls select:focus {
            border-color: #3498db;
        }

        #mapid {
            height: 500px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            position: relative;
            /* Keep relative for inner Leaflet elements */
            margin-bottom: 20px;
            /* Space between map and chart */
        }

        .info-box {
            background: white;
            padding: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            font-size: 14px;
        }

        .legend {
            line-height: 18px;
            color: #555;
            background: white;
            padding: 6px 8px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }

        .map-label-div-icon {
            font-size: 12px;
            font-weight: bold;
            color: #4a4a4a;
            text-align: center;
            line-height: 1.2;
            white-space: nowrap;
            border-radius: 4px;
            padding: 3px 6px;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid #ccc;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        #chartContainer,
        #ageChartContainer,
        #riskChartContainer {
            /* Added #riskChartContainer */
            margin-top: 20px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }

        /* Styles for the stacked horizontal bar chart */
        .stacked-bar-chart,
        .horizontal-bar-chart {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            /* Space between bars */
            padding-top: 15px;
        }

        .bar-item {
            display: flex;
            align-items: center;
            font-size: 14px;
            position: relative;
        }

        .bar-label {
            flex-shrink: 0;
            width: 150px;
            /* Fixed width for labels */
            text-align: right;
            padding-right: 10px;
            font-weight: 500;
            color: #555;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .bar-body {
            flex-grow: 1;
            height: 25px;
            /* Height of the bar */
            border-radius: 4px;
            display: flex;
            overflow: hidden;
            /* Ensure rounded corners apply to children */
            background-color: #e0e0e0;
            /* Fallback for 0% bars */
            cursor: pointer;
            /* Added for tooltip indication on the whole bar */
        }

        .bar-segment {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
            font-size: 13px;
            /* Adjusted font size */
            box-sizing: border-box;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: width 0.5s ease-out;
            /* Smooth transition */
            padding: 0 5px;
            /* Adjusted padding */
            min-width: 45px;
            /* NEW: Minimum width to ensure text visibility */
        }

        /* Specific style for age chart bars (simpler, not stacked) */
        /* REMOVED: .age-bar as it's now stacked */

        .outcome-legend,
        .gender-legend,
        .risk-legend {
            /* Added .risk-legend */
            margin-top: 15px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .outcome-legend-item,
        .gender-legend-item,
        .risk-legend-item {
            /* Added .risk-legend-item */
            display: flex;
            align-items: center;
            font-size: 14px;
            color: #555;
        }

        .outcome-legend-item i,
        .gender-legend-item i,
        .risk-legend-item i {
            /* Added .risk-legend-item i */
            width: 18px;
            height: 18px;
            margin-right: 8px;
            border-radius: 3px;
        }

        /* Styles for Custom Tooltip */
        #customTooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            pointer-events: none;
            /* Allows mouse events to pass through */
            opacity: 0;
            /* Initially hidden */
            transition: opacity 0.2s ease-in-out;
            z-index: 9999;
            /* Ensure it's on top */
            white-space: pre-line;
            /* Allow text wrapping for multiple lines */
            text-align: left;
        }

        #customTooltip.show {
            opacity: 1;
        }

        /* Style for the colored dot in the tooltip */
        .tooltip-color-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }


        /* Define colors for each outcome */
        /* Updated colors based on user request */
        .outcome-Completed {
            background-color: #4CAF50;
            /* เขียว */
        }

        .outcome-Cured {
            background-color: #006400;
            /* เขียวเข้ม */
        }

        .outcome-OnTreatment {
            background-color: #87CEEB;
            /* ฟ้า */
        }

        .outcome-TransferredOut {
            background-color: #CFD8DC;
            /* เทาอ่อน */
        }

        .outcome-Died {
            background-color: #F44336;
            /* แดง */
        }

        .outcome-LostToFollowUp {
            background-color: #FFC107;
            /* เหลืองส้ม */
        }

        .outcome-Failed {
            background-color: #9932CC;
            /* ม่วง */
        }

        .outcome-RRMDRBeforeMonth5 {
            background-color: #FF9800;
            /* ส้ม */
        }

        .outcome-ChangeDiagnosis {
            background-color: #616161;
            /* เทาเข้ม */
        }

        .outcome-Undefined {
            background-color: #B0BEC5;
            /* Light Blue Grey for 'ไม่ระบุ' */
        }

        /* NEW: Define colors for genders */
        .gender-Male {
            background-color: #58bedd;
        }

        /* Blue */
        .gender-Female {
            background-color: #e659de;
        }

        /* Red/Pinkish for contrast */
        .gender-UndefinedGender {
            background-color: #95a5a6;
        }

        /* Grey for undefined gender */

        /* NEW: Define colors for risk levels with diverse palette */
        /* กลุ่ม "ประชากรเสี่ยงต่อวัณโรค" */
        .risk-health-personnel {
            background-color: #1a535c;
        }

        /* Dark Teal */
        .risk-migrant {
            background-color: #4dc7d9;
        }

        /* Light Blue-Green */
        .risk-prisoner-old {
            background-color: #7bd9a2;
        }

        /* Mint Green */
        .risk-prisoner-new {
            background-color: #a7d97b;
        }

        /* Light Green */
        .risk-bedridden {
            background-color: #d9d07b;
        }

        /* Olive Yellow */
        .risk-slum-camp {
            background-color: #d9a77b;
        }

        /* Orange-Brown */
        .risk-detention-center {
            background-color: #d97b7b;
        }

        /* Dusty Rose */

        /* กลุ่ม "ผู้ที่มีโรคหรือภาวะเสี่ยงต่อวัณโรค" */
        .risk-drug-addict {
            background-color: #6a0572;
        }

        /* Dark Purple */
        .risk-smoker {
            background-color: #9338b5;
        }

        /* Medium Purple */
        .risk-b24-patient {
            background-color: #c063e3;
        }

        /* Light Purple */
        .risk-mental-illness {
            background-color: #e69af0;
        }

        /* Lavender */
        .risk-gastric-surgery {
            background-color: #ffc0cb;
        }

        /* Pink */
        .risk-ckd {
            background-color: #a52a2a;
        }

        /* Brown */
        .risk-cancer {
            background-color: #cd5c5c;
        }

        /* Indian Red */
        .risk-alcohol-disorder {
            background-color: #f08080;
        }

        /* Light Coral */
        .risk-history-tb {
            background-color: #ffb6c1;
        }

        /* Light Pink */
        .risk-immunosuppressed {
            background-color: #4a4e4d;
        }

        /* Dark Gray */
        .risk-diabetes {
            background-color: #7b8d8d;
        }

        /* Medium Gray */
        .risk-uncontrolled-diabetes {
            background-color: #b0b5b5;
        }

        /* Light Gray */
        .risk-copd {
            background-color: #d8d8d8;
        }

        /* Very Light Gray */
        .risk-other-medical {
            background-color: #8B4513;
        }

        /* Saddle Brown */

        /* กลุ่ม "ผู้สัมผัสวัณโรค" */
        .risk-close-contact-out {
            background-color: #FFD700;
        }

        /* Gold */
        .risk-household-contact {
            background-color: #DAA520;
        }

        /* Goldenrod */

        /* กลุ่ม "ไม่มีกลุ่มเสี่ยง" */
        .risk-no-risk {
            background-color: #36454F;
        }

        /* Charcoal */
        .risk-undefined-risk {
            background-color: #708090;
        }

        /* Slate Gray */


        /* Loading Overlay Styles */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5em;
            z-index: 2000;
            display: none;
            /* Hidden by default */
            backdrop-filter: blur(5px);
            /* Optional: blur background */
        }

        #loadingOverlay .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }


        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                width: 100%;
                margin: 0;
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
                /* Reduced for tablets */
            }

            #mapid {
                height: 400px;
                /* Slightly reduce map height for tablets */
            }

            .controls {
                position: relative;
                /* Not absolute anymore */
                top: auto;
                left: auto;
                margin-bottom: 15px;
                flex-direction: column;
                align-items: stretch;
                width: auto;
                /* Adjust width to fit container */
                box-sizing: border-box;
            }

            .controls label,
            .controls select {
                width: 100%;
                box-sizing: border-box;
            }

            .bar-label {
                width: 100px;
                /* Adjust label width for smaller screens */
            }

            .bar-segment {
                /* Adjusted for both */
                font-size: 11px;
                /* Smaller font for value on small screens */
                min-width: unset;
                /* Remove min-width on small screens to prevent overflow */
                padding: 0 2px;
            }

            .outcome-legend,
            .gender-legend,
            .risk-legend {
                /* Combined responsive legend */
                flex-direction: column;
                gap: 10px;
            }

            #analysisResults h2 {
                font-size: 1.2em;
            }

            #analysisResults h3 {
                font-size: 1.1em;
            }

            #analysisResults p {
                font-size: 1em;
            }

            #analysisResults ul {
                margin-left: 20px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.2em;
                /* Further reduce for very small phones */
            }

            #mapid {
                height: 300px;
                /* Reduce map height significantly for phones */
            }

            .bar-label {
                width: 80px;
                /* Further adjust label width */
                font-size: 12px;
                /* Smaller font for labels */
            }

            .bar-segment {
                /* Adjusted for both */
                font-size: 9px;
                /* Even smaller font for values */
                padding: 0 1px;
            }

            .bar-body {
                height: 20px;
                /* Slightly thinner bars */
            }

            .outcome-legend-item,
            .gender-legend-item,
            /* Added gender legend item */
            .risk-legend-item,
            /* Added risk legend item */
            .bar-item {
                font-size: 13px;
                /* Smaller general text */
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>แผนที่แสดงจำนวนและข้อมูลผู้ป่วยวัณโรค ปีงบประมาณ 2568</h1>
        <h1>จังหวัดนครสวรรค์</h1>

        <div class="controls">
            <label for="district-filter">เลือกอำเภอ:</label>
            <select id="district-filter">
                <option value="ทั้งหมด">ทั้งหมด</option>
            </select>
            <label for="outcome-filter">ผลการรักษา:</label>
            <select id="outcome-filter">
                <option value="ทั้งหมด">ทั้งหมด</option>
            </select>
            <label for="hospital-filter">เลือกโรงพยาบาล:</label>
            <select id="hospital-filter">
                <option value="ทั้งหมด">ทั้งหมด</option>
            </select>
        </div>

        <div id="mapid">
        </div>

        <div id="chartContainer">
            <h2>ผลงานการรักษาสำเร็จของผู้ป่วยวัณโรคทุกประเภท (All type Success rate) ปีงบประมาณ 2568</h2>
            <div id="outcomeChartLegend" class="outcome-legend"></div>
            <div id="staticHospitalChart" class="stacked-bar-chart"></div>
        </div>

        <div id="ageChartContainer" class="chart-section">
            <h2>จำนวนผู้ป่วยแยกตามช่วงอายุและเพศ</h2>
            <div id="genderChartLegend" class="gender-legend"></div>
            <div id="ageChart" class="stacked-bar-chart"></div>
            <p style="font-size: 0.9em; color: #777; text-align: right; margin-top: 10px;">
                *หมายเหตุ: สำหรับแถบที่มีจำนวนน้อยมาก ความยาวอาจถูกปรับเพื่อให้อ่านตัวเลขได้ชัดเจนขึ้น
            </p>
        </div>

        <div id="riskChartContainer" class="chart-section">
            <h2>จำนวนผู้ป่วยแยกตามกลุ่มเสี่ยงและความเสี่ยง</h2>
            <div id="riskLevelChartLegend" class="risk-legend"></div>
            <div id="riskChart" class="stacked-bar-chart"></div>
            <p style="font-size: 0.9em; color: #777; text-align: right; margin-top: 10px;">
                *หมายเหตุ: สำหรับแถบที่มีจำนวนน้อยมาก ความยาวอาจถูกปรับเพื่อให้อ่านตัวเลขได้ชัดเจนขึ้น
            </p>
        </div>


        <div id="analysisResults">
            <h2>ผลการวิเคราะห์ข้อมูลผู้ป่วยวัณโรค (โดย AI)</h2>
            <div id="analysisParagraphs">
                <p>กำลังโหลดผลการวิเคราะห์...</p>
            </div>
        </div>

    </div>
    <div id="customTooltip"></div>
    <div id="loadingOverlay">
        <div class="spinner"></div>
        <span>กำลังวิเคราะห์ข้อมูล... โปรดรอสักครู่</span>
    </div>

    <script>
        const map = L.map('mapid').setView([13.7563, 100.5018], 6);
        let geoJsonLayer;
        let labelLayerGroup = L.featureGroup().addTo(map);
        let allAggregatedData; // Stores aggregated data for all hospitals
        let rawGeojsonData; // Stores the original, unaggregated GeoJSON data
        let legend;
        const customTooltip = document.getElementById('customTooltip');

        // Define the desired order for outcomes in the chart and legend
        const outcomeDisplayOrder = [
            'Completed',
            'Cured',
            'On treatment',
            'Transferred out',
            'Died',
            'Lost to follow-up',
            'Failed', // Assuming 'Failed' might exist or be added.
            'RR/MDR ก่อนเดือนที่ 5',
            'Change diagnosis',
            'ไม่ระบุ' // Always include 'ไม่ระบุ' at the end
        ];

        // Define a mapping from outcome names to CSS class names for colors
        // Ensure this list is exhaustive of all possible outcomes
        const outcomeColorClasses = {
            'Completed': 'outcome-Completed',
            'Cured': 'outcome-Cured',
            'On treatment': 'outcome-OnTreatment',
            'Transferred out': 'outcome-TransferredOut',
            'Died': 'outcome-Died',
            'Lost to follow-up': 'outcome-LostToFollowUp',
            'Failed': 'outcome-Failed',
            'RR/MDR ก่อนเดือนที่ 5': 'outcome-RRMDRBeforeMonth5',
            'Change diagnosis': 'outcome-ChangeDiagnosis',
            'ไม่ระบุ': 'outcome-Undefined'
        };

        // NEW: Define gender display order and color classes
        const genderDisplayOrder = ['ชาย', 'หญิง', 'ไม่ระบุเพศ'];
        const genderColorClasses = {
            'ชาย': 'gender-Male',
            'หญิง': 'gender-Female',
            'ไม่ระบุเพศ': 'gender-UndefinedGender'
        };

        // NEW: Define risk level display order and color classes based on user's full list
        const riskLevelDisplayOrder = [
            // ประชากรเสี่ยงต่อวัณโรค
            'บุคลากรสาธารณสุขดูแลผู้ป่วย**',
            'ประชากรข้ามชาติ',
            'ผู้ต้องขังในเรือนจำ (รายเก่า)**',
            'ผู้ต้องขังในเรือนจำ (รายใหม่)**',
            'ผู้ป่วยติดบ้านติดเตียง',
            'ผู้อาศัยในชุมชนแออัด/ค่ายอพยพ',
            'ผู้อาศัยในสถานพินิจ**',

            // ผู้ที่มีโรคหรือภาวะเสี่ยงต่อวัณโรค
            'ผู้ติดยาเสพติด**',
            'ผู้ที่สูบบุหรี่**',
            'ผู้ป่วย B24**',
            'ผู้ป่วยจิตเวช',
            'ผู้ป่วยผ่าตัดกระเพาะ ตัดต่อลำใส้',
            'ผู้ป่วยโรคไตเรื้อรัง**',
            'ผู้ป่วยโรคมะเร็ง',
            'ผู้มีความผิดปกติจากการติดสุรา**',
            'ผู้มีประวัติเป็นวัณโรค',
            'โรคที่ได้รับยากดภูมิคุ้มกัน**',
            'โรคเบาหวาน**',
            'โรคเบาหวานที่คุมไม่ได้ (HbA1C ? 7 mg% หรือ FBS**',
            'โรคปอดอุดกั้นเรื้อรัง (COPD)**',
            'อื่นๆ',

            // ผู้สัมผัสวัณโรค
            'ผู้สัมผัสใกล้ชิด (นอกบ้าน)**',
            'ผู้สัมผัสร่วมบ้าน**',

            // ไม่มีกลุ่มเสี่ยง
            'ไม่มีความเสี่ยง',
            'ไม่ระบุความเสี่ยง' // Fallback for undefined data
        ];

        const riskLevelColorClasses = {
            // ประชากรเสี่ยงต่อวัณโรค (โทนสีฟ้า-เขียว)
            'บุคลากรสาธารณสุขดูแลผู้ป่วย**': 'risk-health-personnel',
            'ประชากรข้ามชาติ': 'risk-migrant',
            'ผู้ต้องขังในเรือนจำ (รายเก่า)**': 'risk-prisoner-old',
            'ผู้ต้องขังในเรือนจำ (รายใหม่)**': 'risk-prisoner-new',
            'ผู้ป่วยติดบ้านติดเตียง': 'risk-bedridden',
            'ผู้อาศัยในชุมชนแออัด/ค่ายอพยพ': 'risk-slum-camp',
            'ผู้อาศัยในสถานพินิจ**': 'risk-detention-center',

            // ผู้ที่มีโรคหรือภาวะเสี่ยงต่อวัณโรค (โทนสีม่วง-แดง-น้ำตาล)
            'ผู้ติดยาเสพติด**': 'risk-drug-addict',
            'ผู้ที่สูบบุหรี่**': 'risk-smoker',
            'ผู้ป่วย B24**': 'risk-b24-patient',
            'ผู้ป่วยจิตเวช': 'risk-mental-illness',
            'ผู้ป่วยผ่าตัดกระเพาะ ตัดต่อลำใส้': 'risk-gastric-surgery',
            'ผู้ป่วยโรคไตเรื้อรัง**': 'risk-ckd',
            'ผู้ป่วยโรคมะเร็ง': 'risk-cancer',
            'ผู้มีความผิดปกติจากการติดสุรา**': 'risk-alcohol-disorder',
            'ผู้มีประวัติเป็นวัณโรค': 'risk-history-tb',
            'โรคที่ได้รับยากดภูมิคุ้มกัน**': 'risk-immunosuppressed',
            'โรคเบาหวาน**': 'risk-diabetes',
            'โรคเบาหวานที่คุมไม่ได้ (HbA1C ? 7 mg% หรือ FBS**': 'risk-uncontrolled-diabetes',
            'โรคปอดอุดกั้นเรื้อรัง (COPD)**': 'risk-copd',
            'อื่นๆ': 'risk-other-medical',

            // ผู้สัมผัสวัณโรค (โทนสีเหลือง-ทอง)
            'ผู้สัมผัสใกล้ชิด (นอกบ้าน)**': 'risk-close-contact-out',
            'ผู้สัมผัสร่วมบ้าน**': 'risk-household-contact',

            // ไม่มีกลุ่มเสี่ยง (โทนสีเทา)
            'ไม่มีความเสี่ยง': 'risk-no-risk',
            'ไม่ระบุความเสี่ยง': 'risk-undefined-risk' // Specific class for undefined
        };


        // NEW: Define age group order for consistent display
        const ageGroupOrder = [
            '0-4 ปี', '5-9 ปี', '10-14 ปี', '15-24 ปี', '25-34 ปี',
            '35-44 ปี', '45-54 ปี', '55-64 ปี', '65-100 ปี', 'ไม่ระบุ/เกิน 100 ปี'
        ];

        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        const part1Url = 'final_data_reduced_part_1.geojson';
        const part2Url = 'final_data_reduced_part_2.geojson';

        // โหลดและรวมไฟล์ GeoJSON ทั้งสองไฟล์
        async function loadAndCombineGeoJSON() {
            try {
                const [response1, response2] = await Promise.all([
                    fetch(part1Url),
                    fetch(part2Url)
                ]);

                if (!response1.ok || !response2.ok) {
                    throw new Error('ไม่สามารถดึงข้อมูลจากไฟล์ GeoJSON ได้');
                }

                const data1 = await response1.json();
                const data2 = await response2.json();
                return {
                    "type": "FeatureCollection",
                    "features": [...data1.features, ...data2.features]
                };
            } catch (error) {
                console.error("เกิดข้อผิดพลาดในการโหลดหรือรวมไฟล์:", error);
                return null;
            }
        }

        // รวมข้อมูลผู้ป่วยตาม จังหวัด-อำเภอ-ตำบล
        function aggregateData(geojsonData) {
            const aggregatedFeatures = {};
            geojsonData.features.forEach(feature => {
                const props = feature.properties;
                const geoKey = `${props['จังหวัด']}-${props['อำเภอ']}-${props['ตำบล']}`;
                // Use 'ไม่ระบุ' if outcome is null or undefined
                const outcome = props['ผลการรักษา'] || 'ไม่ระระบุ';

                if (!aggregatedFeatures[geoKey]) {
                    aggregatedFeatures[geoKey] = {
                        type: 'Feature',
                        geometry: feature.geometry,
                        properties: {
                            'จังหวัด': props['จังหวัด'],
                            'อำเภอ': props['อำเภอ'],
                            'ตำบล': props['ตำบล'],
                            'total_count': 0,
                            'outcome_counts': {}
                        }
                    };
                }

                aggregatedFeatures[geoKey].properties.total_count++;

                if (!aggregatedFeatures[geoKey].properties.outcome_counts[outcome]) {
                    aggregatedFeatures[geoKey].properties.outcome_counts[outcome] = 0;
                }
                aggregatedFeatures[geoKey].properties.outcome_counts[outcome]++;
            });

            return {
                "type": "FeatureCollection",
                "features": Object.values(aggregatedFeatures)
            };
        }

        // กำหนดสีตามจำนวนผู้ป่วย (สำหรับแผนที่)
        function getColorForCount(count) {
            return count > 50 ? '#800026' :
                count > 20 ? '#BD0026' :
                    count > 10 ? '#E31A1C' :
                        count > 5 ? '#FC4E2A' :
                            count > 2 ? '#FD8D3C' :
                                count > 0 ? '#FED976' :
                                    '#f0f0f0';
        }

        // สร้าง popup สำหรับแต่ละ feature (แค่ bind popup ไม่ใส่ event hover)
        function onEachFeature(feature, layer) {
            const props = feature.properties;
            const totalCount = props['total_count'];
            let popupContent = `
            <b>จังหวัด:</b> ${props['จังหวัด']}<br>
            <b>อำเภอ:</b> ${props['อำเภอ']}<br>
            <b>ตำบล:</b> ${props['ตำบล']}<br>
            <hr>
            <b>ยอดรวมผู้ป่วย:</b> ${totalCount}<br>
            <hr>
            <b>แบ่งตามผลการรักษา:</b><br>
        `;

            // Sort outcomes for popup consistently (alphabetically or by custom order if desired for popup too)
            // For popup, alphabetical sorting is generally fine for readability
            const sortedOutcomes = Object.keys(props.outcome_counts).sort();
            for (const outcome of sortedOutcomes) {
                const outcomeCount = props.outcome_counts[outcome] || 0;
                const percentage = totalCount > 0 ? ((outcomeCount / totalCount) * 100).toFixed(1) : 0;
                popupContent += `• ${outcome}: ${outcomeCount} ราย (${percentage}%)<br>`;
            }

            layer.bindPopup(popupContent);
        }

        // สร้าง Dropdown สำหรับอำเภอ
        function createDistrictFilter(districts) {
            const selectElement = document.getElementById('district-filter');
            districts.forEach(district => {
                const option = document.createElement('option');
                option.value = district;
                option.textContent = district;
                selectElement.appendChild(option);
            });
            selectElement.addEventListener('change', applyFilters);
        }

        // สร้าง Dropdown สำหรับผลการรักษา
        function createOutcomeFilter(outcomes) {
            const selectElement = document.getElementById('outcome-filter');
            outcomes.forEach(outcome => {
                const option = document.createElement('option');
                option.value = outcome;
                option.textContent = outcome;
                selectElement.appendChild(option);
            });
            selectElement.addEventListener('change', applyFilters);
        }

        // สร้าง Dropdown สำหรับโรงพยาบาล
        function createHospitalFilter(hospitals) {
            const selectElement = document.getElementById('hospital-filter');
            hospitals.forEach(hospital => {
                const option = document.createElement('option');
                option.value = hospital;
                option.textContent = hospital;
                selectElement.appendChild(option);
            });
            selectElement.addEventListener('change', applyFilters);
        }

        // อัพเดท Legend บนแผนที่
        function updateLegend(selectedOutcome) {
            if (legend) {
                legend.remove();
            }

            legend = L.control({ position: 'bottomright' });
            legend.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'info-box legend');
                const grades = [1, 2, 5, 10, 20, 50];
                const legendTitle = selectedOutcome === 'ทั้งหมด' ? 'จำนวนผู้ป่วย' : `จำนวนผู้ป่วย (${selectedOutcome})`;

                div.innerHTML = `<b>${legendTitle}</b><br>`;
                for (let i = 0; i < grades.length; i++) {
                    div.innerHTML +=
                        '<div><i style="background:' + getColorForCount(grades[i] + 1) + '"></i> ' +
                        grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] + '<br>' : '+') + '</div>';
                }
                return div;
            };
            legend.addTo(map);
        }

        // เพิ่มป้ายกำกับจำนวนผู้ป่วยและชื่อตำบลบนแผนที่
        function addLabelsToMap(geoJsonData, selectedOutcome) {
            labelLayerGroup.clearLayers(); // Clear existing labels

            // Only show labels if an specific outcome is selected (not 'ทั้งหมด')
            if (selectedOutcome === 'ทั้งหมด') {
                return;
            }

            geoJsonData.features.forEach(feature => {
                const props = feature.properties;
                let labelText;
                let count = props.outcome_counts[selectedOutcome] || 0;

                // Only create label if count for the selected outcome is greater than 0
                if (count > 0) {
                    const totalCountInTambon = props.total_count;
                    const percentage = totalCountInTambon > 0 ? ((count / totalCountInTambon) * 100).toFixed(1) : 0;
                    labelText = `${props['ตำบล']}<br>(${count} ราย, ${percentage}%)`;

                    const centroid = L.geoJSON(feature.geometry).getBounds().getCenter();
                    const labelIcon = L.divIcon({
                        className: 'map-label-div-icon',
                        html: labelText,
                        iconSize: [0, 0], // Let content size the icon
                        iconAnchor: [0, 0] // Centered by CSS transform
                    });

                    // Using L.marker with custom divIcon for labels
                    L.marker(centroid, { icon: labelIcon }).addTo(labelLayerGroup);
                }
            });
        }

        // ฟังก์ชันสำหรับเตรียมข้อมูลและสร้าง/อัพเดทกราฟแท่งแนวนอน (Stacked)
        function renderStaticHospitalChart(data) {
            const hospitalOutcomeCounts = {}; // { hospitalName: { outcome1: count, outcome2: count, ... }, ... }
            const allOutcomesPresent = new Set(); // To collect all unique outcomes for the legend

            // Calculate overall province data first
            let overallProvinceCounts = { total: 0 };

            data.features.forEach(feature => {
                const hospital = feature.properties['โรงพยาบาล'] || 'ไม่ระบุ';
                const outcome = feature.properties['ผลการรักษา'] || 'ไม่ระบุ';

                // Aggregate for individual hospitals
                if (!hospitalOutcomeCounts[hospital]) {
                    hospitalOutcomeCounts[hospital] = { total: 0 };
                }
                if (!hospitalOutcomeCounts[hospital][outcome]) {
                    hospitalOutcomeCounts[hospital][outcome] = 0;
                }
                hospitalOutcomeCounts[hospital][outcome]++;
                hospitalOutcomeCounts[hospital].total++;

                // Aggregate for overall province
                if (!overallProvinceCounts[outcome]) {
                    overallProvinceCounts[outcome] = 0;
                }
                overallProvinceCounts[outcome]++;
                overallProvinceCounts.total++;

                allOutcomesPresent.add(outcome);
            });

            const sortedHospitals = Object.entries(hospitalOutcomeCounts).sort(([, countsA], [, countsB]) => countsB.total - countsA.total);

            const chartContainer = document.getElementById('staticHospitalChart');
            chartContainer.innerHTML = ''; // Clear existing bars

            if (sortedHospitals.length === 0 && overallProvinceCounts.total === 0) {
                chartContainer.innerHTML = '<p style="text-align: center; color: #777;">ไม่มีข้อมูลผู้ป่วยสำหรับโรงพยาบาล</p>';
                document.getElementById('outcomeChartLegend').innerHTML = ''; // Clear legend too
                return;
            }

            // Render Overall Province Bar (if there's data)
            if (overallProvinceCounts.total > 0) {
                renderBar('ภาพรวม', overallProvinceCounts, chartContainer, outcomeDisplayOrder, outcomeColorClasses);
            }

            // Render individual hospital bars
            sortedHospitals.forEach(([hospitalName, outcomeCounts]) => {
                renderBar(hospitalName, outcomeCounts, chartContainer, outcomeDisplayOrder, outcomeColorClasses);
            });

            // Render chart legend (call separately to ensure all unique outcomes are collected)
            // Filter outcomeDisplayOrder to only include outcomes actually present in the data for the legend
            const relevantOutcomesForLegend = outcomeDisplayOrder.filter(outcome => allOutcomesPresent.has(outcome));
            renderOutcomeChartLegend(relevantOutcomesForLegend);
        }

        // Helper function to render a single bar (for hospital or overall) - Reusable for Age Chart
        function renderBar(name, segmentCounts, containerElement, displayOrder, colorClasses) {
            const barItem = document.createElement('div');
            barItem.classList.add('bar-item');

            const barLabel = document.createElement('div');
            barLabel.classList.add('bar-label');
            barLabel.textContent = name;
            barItem.appendChild(barLabel);

            const barBody = document.createElement('div');
            barBody.classList.add('bar-body');

            // Add event listeners for custom tooltip to the whole barBody
            barBody.addEventListener('mouseover', (e) => {
                let tooltipText = `<b>${name}</b><br>ยอดรวม: ${segmentCounts.total} ราย<br><br>แบ่งตาม:<br>`;
                displayOrder.forEach(segmentKey => {
                    const count = segmentCounts[segmentKey] || 0;
                    if (count > 0 || segmentKey.includes('ไม่ระบุ')) { // Show 'ไม่ระบุ' even if 0 count for clarity
                        const percentage = segmentCounts.total > 0 ? ((count / segmentCounts.total) * 100).toFixed(1) : 0;
                        const colorClass = colorClasses[segmentKey] || 'outcome-Undefined'; // Fallback for outcomes, or gender-UndefinedGender
                        tooltipText += `<span class="tooltip-color-dot ${colorClass}"></span> ${segmentKey}: ${count} ราย (${percentage}%)<br>`;
                    }
                });
                showTooltip(e, tooltipText);
            });
            barBody.addEventListener('mouseout', hideTooltip);
            barBody.addEventListener('mousemove', (e) => {
                moveTooltip(e);
            });

            // Iterate through the predefined display order
            displayOrder.forEach(segmentKey => {
                const count = segmentCounts[segmentKey] || 0;
                const percentage = segmentCounts.total > 0 ? ((count / segmentCounts.total) * 100).toFixed(1) : 0;

                if (parseFloat(percentage) > 0) { // Only create segment if there's data for it
                    const barSegment = document.createElement('div');
                    barSegment.classList.add('bar-segment');
                    barSegment.classList.add(colorClasses[segmentKey] || 'outcome-Undefined'); // Apply color class
                    barSegment.style.width = `${percentage}%`;

                    // Display percentage for segments with value > 0
                    barSegment.textContent = `${percentage}%`; // MODIFIED LINE - Always show percentage if segment exists

                    barBody.appendChild(barSegment);
                }
            });

            barItem.appendChild(barBody);
            containerElement.appendChild(barItem);
        }


        // Function to show custom tooltip
        function showTooltip(event, text) {
            customTooltip.innerHTML = text; // Use innerHTML to allow for HTML in tooltip
            customTooltip.classList.add('show');
            moveTooltip(event);
        }

        // Function to move custom tooltip
        function moveTooltip(event) {
            // Position tooltip relative to mouse cursor
            const xOffset = 15; // Offset from cursor to prevent blocking
            const yOffset = 15;

            // Get boundaries of the chart container to prevent tooltip from going off-screen
            // This needs to be robust, using body or document clientWidth/Height
            const bodyRect = document.body.getBoundingClientRect();
            const tooltipRect = customTooltip.getBoundingClientRect();

            // Add scroll position to clientX/Y
            let newX = event.clientX + window.scrollX + xOffset;
            let newY = event.clientY + window.scrollY + yOffset;

            // Adjust X if tooltip goes off right edge
            if (newX + tooltipRect.width > bodyRect.right - 20) {
                newX = event.clientX + window.scrollX - tooltipRect.width - xOffset;
            }
            // Adjust Y if tooltip goes off bottom edge
            if (newY + tooltipRect.height > bodyRect.bottom - 20) {
                newY = event.clientY + window.scrollY - tooltipRect.height - yOffset;
            }
            // Ensure tooltip doesn't go off the left edge
            if (newX < window.scrollX) {
                newX = window.scrollX;
            }
            // Ensure tooltip doesn't go off the top edge
            if (newY < window.scrollY) {
                newY = window.scrollY;
            }

            customTooltip.style.left = `${newX}px`;
            customTooltip.style.top = `${newY}px`;
        }

        // Function to hide custom tooltip
        function hideTooltip() {
            customTooltip.classList.remove('show');
            customTooltip.innerHTML = ''; // Clear text
        }

        // Function to render the legend for the stacked bar chart (Outcomes)
        function renderOutcomeChartLegend(outcomesToDisplayInLegend) {
            const legendContainer = document.getElementById('outcomeChartLegend');
            legendContainer.innerHTML = ''; // Clear existing legend

            if (outcomesToDisplayInLegend.length === 0) {
                return;
            }

            outcomesToDisplayInLegend.forEach(outcome => {
                const legendItem = document.createElement('div');
                legendItem.classList.add('outcome-legend-item');

                const colorBox = document.createElement('i');
                colorBox.classList.add(outcomeColorClasses[outcome] || 'outcome-Undefined'); // Apply color class
                legendItem.appendChild(colorBox);

                const label = document.createElement('span');
                label.textContent = outcome;
                legendItem.appendChild(label);

                legendContainer.appendChild(legendItem);
            });
        }

        // NEW: Function to render the legend for the gender chart
        function renderGenderChartLegend() {
            const legendContainer = document.getElementById('genderChartLegend');
            legendContainer.innerHTML = ''; // Clear existing legend

            genderDisplayOrder.forEach(gender => {
                const legendItem = document.createElement('div');
                legendItem.classList.add('gender-legend-item');

                const colorBox = document.createElement('i');
                colorBox.classList.add(genderColorClasses[gender]);
                legendItem.appendChild(colorBox);

                const label = document.createElement('span');
                label.textContent = gender;
                legendItem.appendChild(label);

                legendContainer.appendChild(legendItem);
            });
        }

        // NEW: Function to render the legend for the risk level chart
        function renderRiskLevelChartLegend(levelsToDisplayInLegend) {
            const legendContainer = document.getElementById('riskLevelChartLegend');
            legendContainer.innerHTML = '';

            if (levelsToDisplayInLegend.length === 0) {
                return;
            }

            levelsToDisplayInLegend.forEach(level => {
                const legendItem = document.createElement('div');
                legendItem.classList.add('risk-legend-item'); // Reusing class for styling consistency

                const colorBox = document.createElement('i');
                colorBox.classList.add(riskLevelColorClasses[level]);
                legendItem.appendChild(colorBox);

                const label = document.createElement('span');
                label.textContent = level;
                legendItem.appendChild(label);

                legendContainer.appendChild(legendItem);
            });
        }


        // NEW: Function to determine age group
        function getAgeGroup(age) {
            if (age === null || age === undefined || isNaN(age)) return 'ไม่ระบุ/เกิน 100 ปี';
            if (age >= 0 && age <= 4) return '0-4 ปี';
            if (age >= 5 && age <= 9) return '5-9 ปี';
            if (age >= 10 && age <= 14) return '10-14 ปี';
            if (age >= 15 && age <= 24) return '15-24 ปี';
            if (age >= 25 && age <= 34) return '25-34 ปี';
            if (age >= 35 && age <= 44) return '35-44 ปี';
            if (age >= 45 && age <= 54) return '45-54 ปี';
            if (age >= 55 && age <= 64) return '55-64 ปี';
            if (age >= 65 && age <= 100) return '65-100 ปี';
            return 'ไม่ระบุ/เกิน 100 ปี'; // Fallback for ages > 100 or unexpected values
        }

        // NEW: Function to render Age Chart (Stacked by Gender)
        function renderAgeChart(data) {
            const ageChartContainer = document.getElementById('ageChart');
            ageChartContainer.innerHTML = ''; // Clear existing bars

            const ageGroupGenderCounts = {};
            // Initialize all age groups with gender counts
            ageGroupOrder.forEach(group => {
                ageGroupGenderCounts[group] = { total: 0 };
                genderDisplayOrder.forEach(gender => {
                    ageGroupGenderCounts[group][gender] = 0;
                });
            });

            let totalOverallPatients = 0;

            data.features.forEach(feature => {
                const age = feature.properties['อายุ'];
                const gender = feature.properties['เพศ'] || 'ไม่ระบุเพศ'; // Use 'ไม่ระบุเพศ' if gender is null/undefined
                const ageGroup = getAgeGroup(age);

                if (ageGroupGenderCounts[ageGroup]) { // Ensure ageGroup exists in our predefined order
                    ageGroupGenderCounts[ageGroup][gender]++;
                    ageGroupGenderCounts[ageGroup].total++;
                    totalOverallPatients++;
                }
            });

            if (totalOverallPatients === 0) {
                ageChartContainer.innerHTML = '<p style="text-align: center; color: #777;">ไม่มีข้อมูลช่วงอายุผู้ป่วยตามตัวกรองที่เลือก</p>';
                document.getElementById('genderChartLegend').innerHTML = ''; // Clear legend too
                return;
            }

            // Render the gender legend
            renderGenderChartLegend();

            // Render each age group bar
            ageGroupOrder.forEach(group => {
                const groupData = ageGroupGenderCounts[group];
                // Only render a bar if there's any data for this age group
                if (groupData.total > 0) {
                    renderBar(group, groupData, ageChartContainer, genderDisplayOrder, genderColorClasses);
                } else {
                    // If no data, render a gray bar with 0%
                    const barItem = document.createElement('div');
                    barItem.classList.add('bar-item');

                    const barLabel = document.createElement('div');
                    barLabel.classList.add('bar-label');
                    barLabel.textContent = group;
                    barItem.appendChild(barLabel);

                    const barBody = document.createElement('div');
                    barBody.classList.add('bar-body'); // This will make it gray background
                    barBody.textContent = '0 ราย (0.0%)'; // Explicitly show 0%
                    barBody.style.justifyContent = 'center'; // Center the text

                    // Tooltip for 0 data bars
                    barBody.addEventListener('mouseover', (e) => {
                        showTooltip(e, `<b>${group}</b>: 0 ราย (0.0%)`);
                    });
                    barBody.addEventListener('mouseout', hideTooltip);
                    barBody.addEventListener('mousemove', (e) => {
                        moveTooltip(e);
                    });

                    barItem.appendChild(barBody);
                    ageChartContainer.appendChild(barItem);
                }
            });
        }

        // NEW: Function to render Risk Chart (Stacked by Risk Level)
        function renderRiskChart(data) {
            const riskChartContainer = document.getElementById('riskChart');
            riskChartContainer.innerHTML = ''; // Clear existing bars

            const riskGroupRiskLevelCounts = {};
            const allRiskLevelsPresent = new Set(); // To collect all unique risk levels for the legend

            data.features.forEach(feature => {
                const riskGroup = feature.properties['กลุ่มเสี่ยง'] || 'ไม่ระบุกลุ่มเสี่ยง';
                let riskLevel = feature.properties['ความเสี่ยง'] || 'ไม่ระบุความเสี่ยง'; // Use 'let' to allow modification

                // Check if the riskLevel is explicitly defined in riskLevelDisplayOrder
                // If not, and it belongs to 'ผู้ที่มีโรคหรือภาวะเสี่ยงต่อวัณโรค', map it to 'อื่นๆ'
                if (riskGroup === 'ผู้ที่มีโรคหรือภาภาวะเสี่ยงต่อวัณโรค' &&
                    !riskLevelDisplayOrder.includes(riskLevel) &&
                    riskLevel !== 'ไม่ระบุความเสี่ยง' // Don't map 'ไม่ระบุความเสี่ยง' to 'อื่นๆ'
                ) {
                    riskLevel = 'อื่นๆ'; // Map unknown risk levels within this group to 'อื่นๆ'
                } else if (!riskLevelDisplayOrder.includes(riskLevel) && riskLevel !== 'ไม่ระบุความเสี่ยง') {
                    // For other groups, if risk level is not defined, map to 'ไม่ระบุความเสี่ยง'
                    // Or consider if you have specific 'อื่นๆ' for other groups too
                    riskLevel = 'ไม่ระบุความเสี่ยง';
                }

                if (!riskGroupRiskLevelCounts[riskGroup]) {
                    riskGroupRiskLevelCounts[riskGroup] = { total: 0 };
                }
                if (!riskGroupRiskLevelCounts[riskGroup][riskLevel]) {
                    riskGroupRiskLevelCounts[riskGroup][riskLevel] = 0;
                }
                riskGroupRiskLevelCounts[riskGroup][riskLevel]++;
                riskGroupRiskLevelCounts[riskGroup].total++;

                allRiskLevelsPresent.add(riskLevel);
            });

            // Sort risk groups by total count descending
            const sortedRiskGroups = Object.entries(riskGroupRiskLevelCounts).sort(([, countsA], [, countsB]) => countsB.total - countsA.total);

            if (sortedRiskGroups.length === 0) {
                riskChartContainer.innerHTML = '<p style="text-align: center; color: #777;">ไม่มีข้อมูลกลุ่มเสี่ยงและความเสี่ยง</p>';
                document.getElementById('riskLevelChartLegend').innerHTML = '';
                return;
            }

            // Filter riskLevelDisplayOrder to only include levels actually present in the data for the legend
            const relevantRiskLevelsForLegend = riskLevelDisplayOrder.filter(level => allRiskLevelsPresent.has(level));
            renderRiskLevelChartLegend(relevantRiskLevelsForLegend);

            // Render each risk group bar
            sortedRiskGroups.forEach(([groupName, riskCounts]) => {
                renderBar(groupName, riskCounts, riskChartContainer, riskLevelDisplayOrder, riskLevelColorClasses);
            });
        }


        // ฟังก์ชันหลักในการกรองและอัพเดทแผนที่
        function applyFilters() {
            const selectedDistrict = document.getElementById('district-filter').value;
            const selectedOutcome = document.getElementById('outcome-filter').value;
            const selectedHospital = document.getElementById('hospital-filter').value;

            if (geoJsonLayer) {
                map.removeLayer(geoJsonLayer);
            }

            let dataToProcessForMap = rawGeojsonData.features; // Start with all raw data for map
            let dataToProcessForChart = rawGeojsonData.features; // Start with all raw data for charts (hospital and age)

            // Apply Hospital filter to data for ALL charts and analysis
            if (selectedHospital !== 'ทั้งหมด') {
                dataToProcessForChart = dataToProcessForChart.filter(feature =>
                    feature.properties['โรงพยาบาล'] === selectedHospital
                );
                dataToProcessForMap = dataToProcessForMap.filter(feature =>
                    feature.properties['โรงพยาบาล'] === selectedHospital
                );
            }

            // Apply District filter to data for ALL charts and analysis
            // This is the NEW part for dataToProcessForChart
            if (selectedDistrict !== 'ทั้งหมด') {
                dataToProcessForChart = dataToProcessForChart.filter(feature =>
                    feature.properties['อำเภอ'] === selectedDistrict
                );
                dataToProcessForMap = dataToProcessForMap.filter(feature => // This already exists for map
                    feature.properties['อำเภอ'] === selectedDistrict
                );
            }

            // For the map, we aggregate after district/hospital filter
            let currentAggregatedDataForMap = aggregateData({ type: 'FeatureCollection', features: dataToProcessForMap });

            let filteredFeaturesForMap = currentAggregatedDataForMap.features;

            const newStyle = function (feature) {
                let count;
                if (selectedOutcome === 'ทั้งหมด') {
                    count = feature.properties.total_count;
                } else {
                    count = feature.properties.outcome_counts[selectedOutcome] || 0;
                }

                return {
                    color: "#ffffff",
                    weight: 1.5,
                    opacity: 0.8,
                    fillColor: getColorForCount(count),
                    fillOpacity: 0.6
                };
            };

            const filteredGeoJSONForMap = {
                "type": "FeatureCollection",
                "features": filteredFeaturesForMap
            };

            geoJsonLayer = L.geoJSON(filteredGeoJSONForMap, {
                style: newStyle,
                onEachFeature: onEachFeature
            }).addTo(map);

            // Conditionally add hover events for popups if outcome filter is 'ทั้งหมด'
            if (selectedOutcome === 'ทั้งหมด') {
                geoJsonLayer.eachLayer(function (layer) {
                    layer.on({
                        mouseover: function (e) {
                            this.openPopup();
                        },
                        mouseout: function (e) {
                            this.closePopup();
                        }
                    });
                });
            } else { // Remove hover events if a specific outcome is selected
                geoJsonLayer.eachLayer(function (layer) {
                    layer.off('mouseover');
                    layer.off('mouseout');
                });
            }


            if (filteredFeaturesForMap.length > 0) {
                map.fitBounds(geoJsonLayer.getBounds());
            }

            updateLegend(selectedOutcome);
            addLabelsToMap(filteredGeoJSONForMap, selectedOutcome); // Update labels after filtering
            renderStaticHospitalChart({ type: 'FeatureCollection', features: dataToProcessForChart }); // Update hospital chart based on currently filtered raw data
            renderAgeChart({ type: 'FeatureCollection', features: dataToProcessForChart }); // NEW: Update age chart
            renderRiskChart({ type: 'FeatureCollection', features: dataToProcessForChart }); // NEW: Update risk chart

            // Run AI analysis with the filtered raw data for the chart
            runAIAnalysis({ type: 'FeatureCollection', features: dataToProcessForChart });
        }

        // Function to simulate AI analysis and update paragraphs
        // Function to simulate AI analysis and update paragraphs
        async function runAIAnalysis(data) {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const analysisParagraphs = document.getElementById('analysisParagraphs');
            loadingOverlay.style.display = 'flex'; // Show loading overlay
            analysisParagraphs.innerHTML = '<p>กำลังโหลดผลการวิเคราะห์...</p>'; // Reset content

            try {
                const totalPatients = data.features.length;
                let hospitalOutcomeCounts = {}; // To aggregate data per hospital, similar to chart
                let rrMdrAreaCounts = {}; // { 'อำเภอ - ตำBln': count, ... }

                // NEW: Age & Gender Data Aggregation for AI Analysis
                let ageGenderCounts = {}; // { ageGroup: { 'ชาย': count, 'หญิง': count, 'ไม่ระบุเพศ': count, total: count }, ... }
                let overallGenderCounts = { 'ชาย': 0, 'หญิง': 0, 'ไม่ระบุเพศ': 0, total: 0 };

                ageGroupOrder.forEach(group => {
                    ageGenderCounts[group] = { total: 0 };
                    genderDisplayOrder.forEach(gender => {
                        ageGenderCounts[group][gender] = 0;
                    });
                });

                // NEW: Risk Group & Risk Level Data Aggregation for AI Analysis
                let riskGroupCounts = {}; // { riskGroup: { riskLevel1: count, riskLevel2: count, total: count }, ... }
                let allRiskLevelsPresentInAnalysis = new Set();


                data.features.forEach(f => {
                    const hospital = f.properties['โรงพยาบาล'] || 'ไม่ระบุ';
                    const outcome = f.properties['ผลการรักษา'] || 'ไม่ระบุ';

                    if (!hospitalOutcomeCounts[hospital]) {
                        hospitalOutcomeCounts[hospital] = { total: 0, 'Cured': 0, 'Completed': 0, 'Lost to follow-up': 0, 'Died': 0, 'On treatment': 0, 'Change diagnosis': 0, 'RR/MDR ก่อนเดือนที่ 5': 0, 'Transferred out': 0, 'Undefined': 0, 'Failed': 0 };
                    }
                    hospitalOutcomeCounts[hospital].total++;
                    if (hospitalOutcomeCounts[hospital][outcome] !== undefined) {
                        hospitalOutcomeCounts[hospital][outcome]++;
                    } else {
                        hospitalOutcomeCounts[hospital]['Undefined']++; // Fallback for unexpected outcomes
                    }

                    // Aggregate RR/MDR by area
                    if (outcome === 'RR/MDR ก่อนเดือนที่ 5') {
                        const district = f.properties['อำเภอ'] || 'ไม่ระบุอำเภอ';
                        const tambon = f.properties['ตำบล'] || 'ไม่ระบุตำบล';
                        const areaKey = `${district} - ${tambon}`;
                        if (!rrMdrAreaCounts[areaKey]) {
                            rrMdrAreaCounts[areaKey] = 0;
                        }
                        rrMdrAreaCounts[areaKey]++;
                    }

                    // NEW: Aggregate for Age & Gender
                    const age = f.properties['อายุ'];
                    const gender = f.properties['เพศ'] || 'ไม่ระบุเพศ';
                    const ageGroup = getAgeGroup(age);

                    if (ageGenderCounts[ageGroup]) { // Ensure ageGroup exists in our predefined order
                        ageGenderCounts[ageGroup][gender]++;
                        ageGenderCounts[ageGroup].total++;
                    }
                    overallGenderCounts[gender]++;
                    overallGenderCounts.total++;

                    // NEW: Aggregate for Risk Group & Risk Level
                    const riskGroup = f.properties['กลุ่มเสี่ยง'] || 'ไม่ระบุกลุ่มเสี่ยง';
                    let riskLevel = f.properties['ความเสี่ยง'] || 'ไม่ระบุความเสี่ยง';

                    // Apply the same remapping logic as in renderRiskChart
                    if (riskGroup === 'ผู้ที่มีโรคหรือภาภาวะเสี่ยงต่อวัณโรค' &&
                        !riskLevelDisplayOrder.includes(riskLevel) &&
                        riskLevel !== 'ไม่ระบุความเสี่ยง'
                    ) {
                        riskLevel = 'อื่นๆ';
                    } else if (!riskLevelDisplayOrder.includes(riskLevel) && riskLevel !== 'ไม่ระบุความเสี่ยง') {
                        riskLevel = 'ไม่ระบุความเสี่ยง';
                    }

                    if (!riskGroupCounts[riskGroup]) {
                        riskGroupCounts[riskGroup] = { total: 0 };
                    }
                    if (!riskGroupCounts[riskGroup][riskLevel]) {
                        riskGroupCounts[riskGroup][riskLevel] = 0;
                    }
                    riskGroupCounts[riskGroup][riskLevel]++;
                    riskGroupCounts[riskGroup].total++;
                    allRiskLevelsPresentInAnalysis.add(riskLevel);
                });

                // Calculate overall province data for outcomes
                let overallCured = 0;
                let overallCompleted = 0;
                let overallLost = 0;
                let overallDied = 0;
                let overallOnTreatment = 0;
                let overallChangeDiagnosis = 0;
                let overallRRMDR = 0;
                let overallTransferredOut = 0;
                let overallUndefinedOutcome = 0; // Renamed to avoid conflict
                let overallFailed = 0;

                for (const hospital in hospitalOutcomeCounts) {
                    overallCured += hospitalOutcomeCounts[hospital]['Cured'];
                    overallCompleted += hospitalOutcomeCounts[hospital]['Completed'];
                    overallLost += hospitalOutcomeCounts[hospital]['Lost to follow-up'];
                    overallDied += hospitalOutcomeCounts[hospital]['Died'];
                    overallOnTreatment += hospitalOutcomeCounts[hospital]['On treatment'];
                    overallChangeDiagnosis += hospitalOutcomeCounts[hospital]['Change diagnosis'];
                    overallRRMDR += hospitalOutcomeCounts[hospital]['RR/MDR ก่อนเดือนที่ 5'];
                    overallTransferredOut += hospitalOutcomeCounts[hospital]['Transferred out'];
                    overallUndefinedOutcome += hospitalOutcomeCounts[hospital]['Undefined'];
                    overallFailed += hospitalOutcomeCounts[hospital]['Failed'];
                }


                const overallSuccessRate = totalPatients > 0 ? (((overallCured + overallCompleted) / totalPatients) * 100).toFixed(1) : 0;
                const percCured = totalPatients > 0 ? ((overallCured / totalPatients) * 100).toFixed(1) : 0;
                const percCompleted = totalPatients > 0 ? ((overallCompleted / totalPatients) * 100).toFixed(1) : 0;
                const percOnTreatment = totalPatients > 0 ? ((overallOnTreatment / totalPatients) * 100).toFixed(1) : 0;
                const percChangeDiagnosis = totalPatients > 0 ? ((overallChangeDiagnosis / totalPatients) * 100).toFixed(1) : 0;
                const percRRMDR = totalPatients > 0 ? ((overallRRMDR / totalPatients) * 100).toFixed(1) : 0;
                const percTransferredOut = totalPatients > 0 ? ((overallTransferredOut / totalPatients) * 100).toFixed(1) : 0;
                const percLostToFollowUp = totalPatients > 0 ? ((overallLost / totalPatients) * 100).toFixed(1) : 0;
                const percDied = totalPatients > 0 ? ((overallDied / totalPatients) * 100).toFixed(1) : 0;
                const percUndefinedOutcome = totalPatients > 0 ? ((overallUndefinedOutcome / totalPatients) * 100).toFixed(1) : 0;
                const percFailed = totalPatients > 0 ? ((overallFailed / totalPatients) * 100).toFixed(1) : 0;


                // Identify top/bottom performing hospitals based on success rate
                let hospitalPerformance = [];
                for (const hospitalName in hospitalOutcomeCounts) {
                    const hData = hospitalOutcomeCounts[hospitalName];
                    if (hData.total > 0) {
                        const successRate = ((hData['Cured'] + hData['Completed']) / hData.total * 100).toFixed(1);
                        const lostRate = (hData['Lost to follow-up'] / hData.total * 100).toFixed(1);
                        const diedRate = (hData['Died'] / hData.total * 100).toFixed(1);
                        hospitalPerformance.push({
                            name: hospitalName,
                            total: hData.total,
                            successRate: parseFloat(successRate),
                            lostRate: parseFloat(lostRate),
                            diedRate: parseFloat(diedRate)
                        });
                    }
                }

                hospitalPerformance.sort((a, b) => b.successRate - a.successRate); // Sort by success rate descending

                let topHospitals = hospitalPerformance.slice(0, Math.min(3, hospitalPerformance.length));
                let bottomHospitals = hospitalPerformance.slice(Math.max(0, hospitalPerformance.length - 3), hospitalPerformance.length).sort((a, b) => a.successRate - b.successRate);


                // --- Generate Age & Gender Summary ---
                let ageGenderSummary = "";
                let sortedAgeGroups = Object.entries(ageGenderCounts).filter(([, counts]) => counts.total > 0).sort((a, b) => b[1].total - a[1].total);
                if (sortedAgeGroups.length > 0) {
                    const topGroup = sortedAgeGroups[0];
                    const topGroupName = topGroup[0];
                    const topGroupTotal = topGroup[1].total;
                    const topGroupGenderCounts = topGroup[1];
                    let dominantGenderInTopGroup = '';
                    let maxGenderCount = 0;

                    genderDisplayOrder.forEach(gender => {
                        if (topGroupGenderCounts[gender] > maxGenderCount) {
                            maxGenderCount = topGroupGenderCounts[gender];
                            dominantGenderInTopGroup = gender;
                        }
                    });

                    ageGenderSummary = `กราฟแสดงให้เห็นว่า ผู้ป่วยวัณโรคส่วนใหญ่อยู่ในกลุ่มอายุ <strong>${topGroupName}</strong> (${topGroupTotal} ราย)`;
                    if (dominantGenderInTopGroup && maxGenderCount > 0) {
                        ageGenderSummary += ` และส่วนใหญ่เป็นเพศ <strong>${dominantGenderInTopGroup}</strong> (${maxGenderCount} ราย)`;
                    }

                    if (sortedAgeGroups.length > 1) {
                        const secondTopGroup = sortedAgeGroups[1];
                        const secondTopGroupName = secondTopGroup[0];
                        const secondTopGroupTotal = secondTopGroup[1].total;
                        ageGenderSummary += ` รองลงมาคือกลุ่ม <strong>${secondTopGroupName}</strong> (${secondTopGroupTotal} ราย)`;
                    }
                    ageGenderSummary += ". ข้อมูลนี้เป็นประโยชน์ในการวางแผนการเฝ้าระวังและเข้าถึงกลุ่มเป้าหมายในแต่ละช่วงวัยและเพศ.";
                } else {
                    ageGenderSummary = "ไม่พบข้อมูลช่วงอายุและเพศผู้ป่วยสำหรับวิเคราะห์.";
                }


                // --- Generate Risk Group & Risk Level Summary ---
                let riskGroupAnalysisSummary = "";
                let sortedRiskGroups = Object.entries(riskGroupCounts).filter(([, counts]) => counts.total > 0).sort((a, b) => b[1].total - a[1].total);
                if (sortedRiskGroups.length > 0) {
                    const topRiskGroup = sortedRiskGroups[0];
                    const topRiskGroupName = topRiskGroup[0];
                    const topRiskGroupTotal = topRiskGroup[1].total;
                    const topRiskGroupLevelCounts = topRiskGroup[1];

                    // Filter to only levels within this specific group and find the dominant ones
                    const relevantLevelsInTopGroup = Object.entries(topRiskGroupLevelCounts)
                        .filter(([key, value]) => key !== 'total' && value > 0)
                        .sort((a, b) => b[1] - a[1]); // Sort by count descending

                    riskGroupAnalysisSummary = `จากการวิเคราะห์กลุ่มเสี่ยงหลักพบว่า <strong>${topRiskGroupName}</strong> มีจำนวนผู้ป่วยมากที่สุด (${topRiskGroupTotal} ราย)`;

                    if (relevantLevelsInTopGroup.length > 0) {
                        riskGroupAnalysisSummary += ` โดยมีความเสี่ยงย่อยที่เด่นชัดคือ <strong>${relevantLevelsInTopGroup[0][0]}</strong> (${relevantLevelsInTopGroup[0][1]} ราย)`;
                    }
                    if (relevantLevelsInTopGroup.length > 1) {
                        riskGroupAnalysisSummary += `, อันดับ 2 คือ <strong>${relevantLevelsInTopGroup[1][0]}</strong> (${relevantLevelsInTopGroup[1][1]} ราย)`;
                    }
                    if (relevantLevelsInTopGroup.length > 2) {
                        riskGroupAnalysisSummary += ` และอันดับ 3 คือ <strong>${relevantLevelsInTopGroup[2][0]}</strong> (${relevantLevelsInTopGroup[2][1]} ราย)`;
                    }
                    riskGroupAnalysisSummary += ". การทำความเข้าใจกลุ่มเสี่ยงเหล่านี้จะช่วยให้สามารถดำเนินมาตรการป้องกันและคัดกรองได้อย่างตรงจุดและมีประสิทธิภาพยิ่งขึ้น.";

                    if (sortedRiskGroups.length > 1) {
                        const secondTopRiskGroup = sortedRiskGroups[1];
                        const secondTopRiskGroupName = secondTopRiskGroup[0];
                        const secondTopRiskGroupTotal = secondTopRiskGroup[1].total;
                        riskGroupAnalysisSummary += `<br>กลุ่มเสี่ยงหลักรองลงมาคือ <strong>${secondTopRiskGroupName}</strong> (${secondTopRiskGroupTotal} ราย).`;
                    }
                } else {
                    riskGroupAnalysisSummary = "ไม่พบข้อมูลกลุ่มเสี่ยงและความเสี่ยงผู้ป่วยสำหรับวิเคราะห์.";
                }


                // Generate analysis paragraphs
                let analysisContent = '';

                if (totalPatients === 0) {
                    analysisContent = '<p><b>ไม่มีข้อมูลผู้ป่วยให้วิเคราะห์ตามเงื่อนไขที่เลือก.</b></p>';
                } else {
                    // Section 1: ภาพรวมข้อมูลผู้ป่วย
                    analysisContent += `<h3>ภาพรวมข้อมูลผู้ป่วย</h3>`;
                    analysisContent += `<p>ข้อมูลผู้ป่วยวัณโรคจำนวน <b>${totalPatients} ราย</b> (ตามตัวกรองปัจจุบัน) แสดงผลการรักษาดังนี้:</p>
                        <ul>
                            <li><b>รักษาหาย (Cured):</b> ${overallCured} ราย (${percCured}%)</li>
                            <li><b>รักษาครบ (Completed):</b> ${overallCompleted} ราย (${percCompleted}%)</li>
                            <li><b>ยังอยู่ระหว่างรักษา (On treatment):</b> ${percOnTreatment > 0 ? `${overallOnTreatment} ราย (${percOnTreatment}%)` : '0 ราย'}</li>
                            <li><b>เปลี่ยนการวินิจฉัย:</b> ${percChangeDiagnosis > 0 ? `${overallChangeDiagnosis} ราย (${percChangeDiagnosis}%)` : '0 ราย'}</li>
                            <li><b>RR/MDR ก่อนเดือนที่ 5:</b> ${percRRMDR > 0 ? `${overallRRMDR} ราย (${percRRMDR}%)` : '0 ราย'}</li>
                            <li><b>ย้ายออก:</b> ${percTransferredOut > 0 ? `${overallTransferredOut} ราย (${percTransferredOut}%)` : '0 ราย'}</li>
                            <li><b>ขาดการรักษา (Lost to follow-up):</b> ${percLostToFollowUp > 0 ? `${overallLost} ราย (${percLostToFollowUp}%)` : '0 ราย'}</li>
                            <li><b>เสียชีวิต:</b> ${percDied > 0 ? `${overallDied} ราย (${percDied}%)` : '0 ราย'}</li>
                            ${overallFailed > 0 ? `<li><b>ล้มเหลว (Failed):</b> ${overallFailed} ราย (${percFailed}%)</li>` : ''}
                            ${overallUndefinedOutcome > 0 ? `<li><b>ไม่ระบุ:</b> ${overallUndefinedOutcome} ราย (${percUndefinedOutcome}%)</li>` : ''}
                        </ul>
                        <p>โดยรวมแล้ว อัตราความสำเร็จของการรักษา (หาย + ครบ) อยู่ที่ <b>${overallSuccessRate}%</b></p>
                    `;

                    // Section 2: ผลงานของโรงพยาบาล
                    analysisContent += `<h3>ผลงานของโรงพยาบาล</h3>`;
                    if (topHospitals.length > 0) {
                        analysisContent += `<p>โรงพยาบาลที่มีอัตราความสำเร็จสูง 3 อันดับแรกคือ: `;
                        topHospitals.forEach((h, index) => {
                            analysisContent += `<b>${h.name}</b> (สำเร็จ ${h.successRate}%)`;
                            if (index < topHospitals.length - 1) analysisContent += ', ';
                        });
                        analysisContent += `. โรงพยาบาลเหล่านี้ทำผลงานได้ดี ควรนำไปเป็นตัวอย่าง.</p>`;
                    }

                    if (bottomHospitals.length > 0 && bottomHospitals.length !== hospitalPerformance.length) {
                        const hospitalsWithIssues = bottomHospitals.filter(h => h.lostRate > 0 || h.diedRate > 0);
                        if (hospitalsWithIssues.length > 0) {
                            analysisContent += `<p>ส่วนโรงพยาบาลที่ยังมีความท้าทาย โดยมีสัดส่วนผู้ป่วยขาดการรักษาหรือเสียชีวิตสูง ได้แก่ ${hospitalsWithIssues.map(h => `<b>${h.name}</b>`).join(', ')}. โรงพยาบาลเหล่านี้ต้องพิจารณาหาสาเหตุและปรับปรุงการดูแลผู้ป่วย.</p>`;
                        }
                    }
                    analysisContent += `<p>สามารถดูรายละเอียดผลงานของแต่ละโรงพยาบาลได้จากกราฟแท่งด้านบน.</p>`;

                    // --- NEW SECTION: การวิเคราะห์ตามช่วงอายุและเพศ ---
                    analysisContent += `<h3>การวิเคราะห์ตามช่วงอายุและเพศ</h3>`;
                    analysisContent += `<p>${ageGenderSummary}</p>`;

                    // --- NEW SECTION: การวิเคราะห์ตามกลุ่มเสี่ยงและความเสี่ยง ---
                    analysisContent += `<h3>การวิเคราะห์ตามกลุ่มเสี่ยงและความเสี่ยง</h3>`;
                    analysisContent += `<p>${riskGroupAnalysisSummary}</p>`;


                    // Section 3: การเฝ้าระวังผู้ป่วยดื้อยา (RR/MDR)
                    analysisContent += `<h3>การเฝ้าระวังผู้ป่วยดื้อยา (RR/MDR)</h3>`;
                    const rrMdrAreas = Object.entries(rrMdrAreaCounts).filter(([, count]) => count > 0).sort((a, b) => b[1] - a[1]);

                    if (overallRRMDR > 0) {
                        analysisContent += `<p>พบผู้ป่วยที่วินิจฉัยว่าเป็นวัณโรคดื้อยา (RR/MDR) จำนวน <b>${overallRRMDR} ราย</b> ในพื้นที่ดังต่อไปนี้ (เรียงตามจำนวนมากไปน้อย):</p><ul>`;
                        rrMdrAreas.forEach(([area, count]) => {
                            analysisContent += `<li><b>${area}</b>: ${count} ราย</li>`;
                        });
                        analysisContent += `</ul><p>การเฝ้าระวังและติดตามผู้ป่วยในพื้นที่เหล่านี้อย่างใกล้ชิดมีความสำคัญอย่างยิ่ง เพื่อป้องกันการแพร่กระจายของเชื้อดื้อยาและควบคุมสถานการณ์ในระยะยาว.</p>`;
                    } else {
                        analysisContent += `<p>ไม่พบผู้ป่วยวัณโรคดื้อยา (RR/MDR) ในข้อมูลที่เลือก.</p>`;
                    }


                    // Section 4: ข้อสังเกตและคำแนะนำ
                    analysisContent += `<h3>ข้อสังเกตและคำแนะนำ</h3>`;
                    analysisContent += `<p>หากดูจากข้อมูลที่ผ่านมา มีข้อสังเกตและคำแนะนำดังนี้:</p><ul>`;

                    if (parseFloat(overallSuccessRate) >= 80) {
                        analysisContent += `<li><b>อัตราสำเร็จสูง:</b> ภาพรวมการรักษาวัณโรคในจังหวัดทำได้ดี ควรพยายามรักษาระดับนี้ไว้และแลกเปลี่ยนวิธีการทำงานกับโรงพยาบาลอื่น.</li>`;
                    } else {
                        analysisContent += `<li><b>ต้องปรับปรุงอัตราสำเร็จ:</b> อัตราความสำเร็จโดยรวมยังไม่ถึงเป้าหมาย (80%) ควรทบทวนขั้นตอนการรักษาและหาทางเพิ่มประสิทธิภาพ.</li>`;
                    }

                    if (parseFloat(percLostToFollowUp) > 10) {
                        analysisContent += `<li><b>ผู้ป่วยขาดการรักษาเยอะ:</b> มีผู้ป่วยจำนวนมากที่ขาดการติดตาม ซึ่งอาจทำให้การแพร่เชื้อยังคงอยู่ ควรมีการติดตามผู้ป่วยอย่างใกล้ชิดมากขึ้น เช่น การโทรศัพท์ หรือส่ง อสม. ไปเยี่ยม.</li>`;
                    }

                    if (parseFloat(percDied) > 5) {
                        analysisContent += `<li><b>อัตราเสียชีวิตสูง: เพื่อวิเคราะห์และระบุว่าผู้ป่วยมีอากรหนักหรือไม่</b> ผู้ป่วยวัณโรคเสียชีวิตค่อนข้างมาก ควรตรวจสอบว่ามีสาเหตุใดที่สามารถป้องกันได้ และปรับปรุงการดูแลผู้ป่วยกลุ่มที่มีอาการหนักหรือมีโรคประจำตัว.</li>`;
                    }
                    // Add advice for Failed if present
                    if (parseFloat(percFailed) > 0 && parseFloat(percFailed) > parseFloat(percLostToFollowUp) && parseFloat(percFailed) > parseFloat(percDied)) { // Simple heuristic
                        analysisContent += `<li><b>ผลการรักษาล้มเหลว:</b> พบผู้ป่วยมีผลการรักษาล้มเหลว (${percFailed}%) ซึ่งบ่งชี้ว่าการรักษาอาจไม่เป็นไปตามแผน ควรทบทวนแนวทางการรักษาและพิจารณาปัจจัยที่ทำให้การรักษาไม่ได้ผล.</li>`;
                    }

                    analysisContent += `</ul><p>การปรับปรุงจุดที่พบปัญหาจะช่วยให้การควบคุมวัณโรคในจังหวัดนครสวรรค์ดีขึ้นได้.</p>`;
                }


                analysisParagraphs.innerHTML = analysisContent;

            } catch (error) {
                console.error("Error running AI analysis:", error);
                analysisParagraphs.innerHTML = '<p style="color: red;">เกิดข้อผิดพลาดในการวิเคราะห์ข้อมูล. โปรดลองใหม่อีกครั้ง.</p><p style="color: red;">(ข้อผิดพลาดนี้อาจเกิดจากการจำลอง API หรือการเชื่อมต่อกับ AI Backend ที่ยังไม่ได้ตั้งค่า)</p>';
            } finally {
                loadingOverlay.style.display = 'none'; // Hide loading overlay
            }
        }

        // เริ่มต้นการทำงานของแอปพลิเคชัน
        loadAndCombineGeoJSON().then(geojsonData => {
            if (geojsonData) {
                rawGeojsonData = geojsonData; // Store raw data
                allAggregatedData = aggregateData(geojsonData); // Aggregate all data for initial 'ทั้งหมด' state

                const districts = [...new Set(allAggregatedData.features.map(f => f.properties['อำเภอ']))].sort();

                const allOutcomes = new Set();
                rawGeojsonData.features.forEach(feature => { // Get all outcomes from raw data
                    const outcome = feature.properties['ผลการรักษา'] || 'ไม่ระบุ';
                    allOutcomes.add(outcome);
                });
                const outcomes = [...allOutcomes].sort(); // Keep this for the filter dropdown, it's alphabetical

                const hospitals = [...new Set(rawGeojsonData.features.map(f => f.properties['โรงพยาบาล']))].sort(); // Extract hospitals from raw data

                createDistrictFilter(districts);
                createOutcomeFilter(outcomes);
                createHospitalFilter(hospitals); // Create hospital filter

                // Initial map load uses all aggregated data
                geoJsonLayer = L.geoJSON(allAggregatedData, {
                    style: function (feature) {
                        return {
                            color: "#ffffff",
                            weight: 1.5,
                            opacity: 0.8,
                            fillColor: getColorForCount(feature.properties.total_count),
                            fillOpacity: 0.6
                        };
                    },
                    onEachFeature: onEachFeature
                }).addTo(map);

                // Add hover events for popups on initial load (since outcome filter is 'ทั้งหมด')
                geoJsonLayer.eachLayer(function (layer) {
                    layer.on({
                        mouseover: function (e) {
                            this.openPopup();
                        },
                        mouseout: function (e) {
                            this.closePopup();
                        }
                    });
                });


                map.fitBounds(geoJsonLayer.getBounds());

                updateLegend('ทั้งหมด');
                // Initial call to addLabelsToMap, checks current filter state
                addLabelsToMap(allAggregatedData, document.getElementById('outcome-filter').value);
                // Initial chart render with all raw data
                renderStaticHospitalChart(rawGeojsonData);
                renderAgeChart(rawGeojsonData); // Initial render of age chart
                renderRiskChart(rawGeojsonData); // Initial render of risk chart

                // Initial AI analysis run after everything loads
                runAIAnalysis(rawGeojsonData);
            }
        });

        L.control.scale({ imperial: false, position: 'bottomleft' }).addTo(map);
    </script>

</body>

</html>
